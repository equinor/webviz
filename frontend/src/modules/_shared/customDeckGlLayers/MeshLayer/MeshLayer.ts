import {
    Accessor,
    Color,
    DefaultProps,
    Layer,
    LayerProps,
    Material,
    Position,
    UpdateParameters,
    picking,
    project32,
} from "@deck.gl/core";
import { getMeshBoundingBox } from "@loaders.gl/schema";
import { Model } from "@luma.gl/engine";
import { phongMaterial } from "@luma.gl/shadertools";
import { utilities } from "@webviz/subsurface-viewer/dist/layers/shader_modules";

import fs from "./_shaders/fragment.glsl?raw";
import vs from "./_shaders/vertex.glsl?raw";
import { getGeometry } from "./utils";

import { Mesh } from "../types";

type _MeshLayerProps<TData = unknown> = {
    mesh: string | Mesh | Promise<Mesh> | null;
    getPosition?: Accessor<TData, Position>;
    getColor?: Accessor<TData, Color>;
    getOrientation?: Accessor<TData, [number, number, number]>;
    getScale?: Accessor<TData, [number, number, number]>;
    getTranslation?: Accessor<TData, [number, number, number]>;
    sizeScale?: number;
    material?: Material;
    wireframe?: boolean;
    // _instanced is a hack to use world position instead of meter offsets in mesh
    // TODO - formalize API
    _instanced: true;
};

export type MeshLayerProps<TData = unknown> = _MeshLayerProps<TData> & LayerProps;

const DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];

const defaultProps: DefaultProps<MeshLayerProps> = {
    mesh: { type: "object", value: null, async: true },
    getPosition: { type: "accessor", value: (d: any) => d.position },
    getColor: { type: "accessor", value: DEFAULT_COLOR },
    getOrientation: { type: "accessor", value: [0, 0, 0] },
    getScale: { type: "accessor", value: [1, 1, 1] },
    getTranslation: { type: "accessor", value: [0, 0, 0] },
    material: true,
    wireframe: false,
    _instanced: true,
};

export class MeshLayer<TData = any, TExtraProps extends {} = {}> extends Layer<
    TExtraProps & Required<_MeshLayerProps<TData>>
> {
    static layerName: string = "MeshLayer";
    static defaultProps = defaultProps;

    // @ts-expect-error - state is working in deck.gl
    state!: {
        model?: Model;
        hasNormals?: boolean;
        positionBounds?: [number[], number[]] | null;
    };

    getShaders() {
        return super.getShaders({
            vs,
            fs,
            modules: [project32, phongMaterial, picking, utilities],
        });
    }

    getBounds(): [number[], number[]] | null {
        if (this.props._instanced) {
            return super.getBounds();
        }
        let result = this.state.positionBounds;
        if (result) {
            return result;
        }
        const { mesh } = this.props;
        if (!mesh) {
            return null;
        }
        // @ts-ignore Detect if mesh is generated by loaders.gl
        result = mesh.header?.boundingBox;

        if (!result) {
            // Otherwise, calculate bounding box from positions
            const { attributes } = getGeometry(mesh as Mesh);
            attributes.POSITION = attributes.POSITION || attributes.positions;

            //@ts-expect-error
            result = getMeshBoundingBox(attributes);
        }

        this.state.positionBounds = result;
        return result;
    }

    initializeState() {
        const attributeManager = this.getAttributeManager();
        // attributeManager is always defined in a primitive layer
        attributeManager!.addInstanced({
            instancePositions: {
                transition: true,
                type: "float64",
                fp64: this.use64bitPositions(),
                size: 3,
                accessor: "getPosition",
            },
        });
    }

    updateState(params: UpdateParameters<this>) {
        super.updateState(params);

        const { props, oldProps, changeFlags } = params;
        if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
            this.state.positionBounds = null;
            this.state.model?.destroy();
            if (props.mesh) {
                this.state.model = this.getModel(props.mesh as Mesh);

                const attributes = (props.mesh as any).attributes || props.mesh;
                this.setState({
                    hasNormals: Boolean(attributes.NORMAL || attributes.normals),
                });
            }
            // attributeManager is always defined in a primitive layer
            this.getAttributeManager()!.invalidateAll();
        }

        if (this.state.model) {
            this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
        }
    }

    draw({ uniforms }: { uniforms: any }) {
        const { model } = this.state;
        if (!model) {
            return;
        }

        const { renderPass } = this.context;
        const { sizeScale } = this.props;

        model.setUniforms(uniforms);
        model.setUniforms({
            sizeScale,
            flatShading: !this.state.hasNormals,
        });
        model.draw(renderPass);
    }

    get isLoaded(): boolean {
        return Boolean(this.state?.model && super.isLoaded);
    }

    protected getModel(mesh: Mesh): Model {
        const model = new Model(this.context.device, {
            ...this.getShaders(),
            id: this.props.id,
            bufferLayout: this.getAttributeManager()!.getBufferLayouts(),
            geometry: getGeometry(mesh),
            isInstanced: true,
        });

        return model;
    }
}
