// This file is auto-generated by @hey-api/openapi-ts

export type ALQ_api = 'GRAT' | 'IGLR' | 'TGLR' | 'PUMP' | 'COMP' | 'DENO' | 'DENG' | 'BEAN' | "''";

export type B64FloatArray_api = {
    element_type_api: 'float32' | 'float64';
    data_b64str: string;
};

export type element_type_api = 'float32' | 'float64';

export type B64UintArray_api = {
    element_type_api: 'uint8' | 'uint16' | 'uint32' | 'uint64';
    data_b64str: string;
};

export type element_type2_api = 'uint8' | 'uint16' | 'uint32' | 'uint64';

export type Body_post_get_aggregated_per_realization_table_data_api = {
    /**
     * Selected identifiers and wanted values
     */
    identifiers_with_values: Array<InplaceVolumetricsIdentifierWithValues_api>;
};

export type Body_post_get_aggregated_statistical_table_data_api = {
    /**
     * Selected identifiers and wanted values
     */
    identifiers_with_values: Array<InplaceVolumetricsIdentifierWithValues_api>;
};

export type Body_post_get_polyline_intersection_api = {
    polyline_utm_xy: Array<(number)>;
};

export type Body_post_get_seismic_fence_api = {
    polyline: SeismicFencePolyline_api;
};

export type Body_post_get_surface_intersection_api = {
    cumulative_length_polyline: SurfaceIntersectionCumulativeLengthPolyline_api;
};

export type Body_post_sample_surface_in_points_api = {
    sample_points: PointSetXY_api;
};

export type BoundingBox2d_api = {
    min_x: number;
    min_y: number;
    max_x: number;
    max_y: number;
};

/**
 * Bounding box for a 3D grid geometry
 */
export type BoundingBox3d_api = {
    xmin: number;
    ymin: number;
    zmin: number;
    xmax: number;
    ymax: number;
    zmax: number;
};

export type CaseInfo_api = {
    uuid: string;
    name: string;
    status: string;
    user: string;
};

export type Completions_api = {
    sortedCompletionDateIndices: Array<(number)>;
    open: Array<(number)>;
    shut: Array<(number)>;
    khMean: Array<(number)>;
    khMin: Array<(number)>;
    khMax: Array<(number)>;
};

export type DatedTree_api = {
    dates: Array<(string)>;
    tree: TreeNode_api;
};

export type EnsembleDetails_api = {
    name: string;
    field_identifier: string;
    case_name: string;
    case_uuid: string;
    realizations: Array<(number)>;
};

export type EnsembleInfo_api = {
    name: string;
    realization_count: number;
};

/**
 * Description/data for a single parameter in an ensemble
 */
export type EnsembleParameter_api = {
    name: string;
    is_logarithmic: boolean;
    is_numerical: boolean;
    is_constant: boolean;
    group_name: (string | null);
    descriptive_name: (string | null);
    realizations: Array<(number)>;
    values: (Array<(number)> | Array<(string)>);
};

export type EnsembleParameterDescription_api = {
    name: string;
    group_name: (string | null);
    descriptive_name: (string | null);
    is_numerical: boolean;
};

/**
 * A generic type for a scalar response from each of the members of the ensemble.
 */
export type EnsembleScalarResponse_api = {
    realizations: Array<(number)>;
    values: Array<(number)>;
    name: (string | null);
    unit: (string | null);
};

/**
 * Description/data for a single sensitivity in an ensemble
 */
export type EnsembleSensitivity_api = {
    name: string;
    type: SensitivityType_api;
    cases: Array<EnsembleSensitivityCase_api>;
};

/**
 * Description/data for a single sensitivity case in an ensemble
 */
export type EnsembleSensitivityCase_api = {
    name: string;
    realizations: Array<(number)>;
};

export type FenceMeshSection_api = {
    vertices_uz_b64arr: B64FloatArray_api;
    poly_indices_b64arr: B64UintArray_api;
    vertices_per_poly_b64arr: B64UintArray_api;
    poly_source_cell_indices_b64arr: B64UintArray_api;
    poly_props_b64arr: B64FloatArray_api;
    start_utm_x: number;
    start_utm_y: number;
    end_utm_x: number;
    end_utm_y: number;
};

export type FieldInfo_api = {
    field_identifier: string;
};

export type FlowRateType_api = 'OIL' | 'LIQ' | 'GAS' | 'WG' | 'TM' | 'WAT';

export type FluidZone_api = 'Oil' | 'Gas' | 'Water';

export type Frequency_api = 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'QUARTERLY' | 'YEARLY';

export type GFR_api = 'GOR' | 'GLR' | 'OGR' | 'MMW';

export type GraphUserPhoto_api = {
    avatar_b64str: (string | null);
};

/**
 * Specification of a 3D grid dimensions
 */
export type Grid3dDimensions_api = {
    i_count: number;
    j_count: number;
    k_count: number;
    subgrids: Array<Grid3dZone_api>;
};

export type Grid3dGeometry_api = {
    polys_b64arr: B64UintArray_api;
    points_b64arr: B64FloatArray_api;
    poly_source_cell_indices_b64arr: B64UintArray_api;
    origin_utm_x: number;
    origin_utm_y: number;
    xmin: number;
    xmax: number;
    ymin: number;
    ymax: number;
    zmin: number;
    zmax: number;
};

/**
 * Metadata for a 3D grid model, including its properties and geometry
 */
export type Grid3dInfo_api = {
    grid_name: string;
    bbox: BoundingBox3d_api;
    dimensions: Grid3dDimensions_api;
    property_info_arr: Array<Grid3dPropertyInfo_api>;
};

export type Grid3dMappedProperty_api = {
    poly_props_b64arr: B64FloatArray_api;
    min_grid_prop_value: number;
    max_grid_prop_value: number;
};

/**
 * Metadata for a 3D grid property
 */
export type Grid3dPropertyInfo_api = {
    property_name: string;
    iso_date_or_interval: (string | null);
};

/**
 * Named subset of 3D grid layers (Zone)
 */
export type Grid3dZone_api = {
    name: string;
    start_layer: number;
    end_layer: number;
};

export type GridDimensions_api = {
    i_count: number;
    j_count: number;
    k_count: number;
};

export type GroupTreeData_api = {
    edge_metadata_list: Array<GroupTreeMetadata_api>;
    node_metadata_list: Array<GroupTreeMetadata_api>;
    dated_trees: Array<DatedTree_api>;
};

export type GroupTreeMetadata_api = {
    key: string;
    label: string;
};

export type HTTPValidationError_api = {
    detail?: Array<ValidationError_api>;
};

/**
 * Statistical volumetric data for single volume table
 *
 * Contains data for a single fluid zone, e.g. Oil, Gas, Water, or sum of fluid zones
 */
export type InplaceStatisticalVolumetricTableData_api = {
    fluidSelectionName: string;
    selectorColumns: Array<RepeatedTableColumnData_api>;
    resultColumnStatistics: Array<TableColumnStatisticalData_api>;
};

/**
 * Statistical volumetric data for a single table per fluid selection
 *
 * Fluid selection can be single fluid zones, e.g. Oil, Gas, Water, or sum of fluid zones - Oil + Gas + Water
 */
export type InplaceStatisticalVolumetricTableDataPerFluidSelection_api = {
    tableDataPerFluidSelection: Array<InplaceStatisticalVolumetricTableData_api>;
};

/**
 * Allowed volumetric response names
 */
export type InplaceVolumetricResultName_api = 'BULK' | 'NET' | 'PORO' | 'PORO_NET' | 'PORV' | 'HCPV' | 'STOIIP' | 'GIIP' | 'NTG' | 'ASSOCIATEDGAS' | 'ASSOCIATEDOIL' | 'BO' | 'BG' | 'SW' | 'STOIIP_TOTAL' | 'GIIP_TOTAL';

export type InplaceVolumetricsIdentifier_api = 'ZONE' | 'REGION' | 'FACIES' | 'LICENSE';

/**
 * Unique values for an index column in a volumetric table
 * All values should ideally be strings, but it is common to see integers, especially for REGION
 */
export type InplaceVolumetricsIdentifierWithValues_api = {
    identifier: InplaceVolumetricsIdentifier_api;
    values: Array<(string | number)>;
};

/**
 * Definition of a volumetric table
 */
export type InplaceVolumetricsTableDefinition_api = {
    tableName: string;
    fluidZones: Array<FluidZone_api>;
    resultNames: Array<InplaceVolumetricResultName_api>;
    identifiersWithValues: Array<InplaceVolumetricsIdentifierWithValues_api>;
};

/**
 * Definition of possible statistics for a result column in an inplace volumetrics table
 */
export type InplaceVolumetricStatistic_api = 'mean' | 'stddev' | 'max' | 'min' | 'p10' | 'p90';

/**
 * Volumetric data for a single table
 *
 * Contains data for a single fluid zone, e.g. Oil, Gas, Water, or sum of fluid zones
 */
export type InplaceVolumetricTableData_api = {
    fluidSelectionName: string;
    selectorColumns: Array<RepeatedTableColumnData_api>;
    resultColumns: Array<TableColumnData_api>;
};

/**
 * Volumetric data for a single table per fluid selection
 *
 * Fluid selection can be single fluid zones, e.g. Oil, Gas, Water, or sum of fluid zones - Oil + Gas + Water
 */
export type InplaceVolumetricTableDataPerFluidSelection_api = {
    tableDataPerFluidSelection: Array<InplaceVolumetricTableData_api>;
};

export type NodeType_api = 'prod' | 'inj' | 'other';

/**
 * A collection of observations associated with a field/case/ensemble
 */
export type Observations_api = {
    summary: Array<SummaryVectorObservations_api>;
    rft: Array<RftObservations_api>;
};

export type PointSetXY_api = {
    x_points: Array<(number)>;
    y_points: Array<(number)>;
};

export type PolygonData_api = {
    x_arr: Array<(number)>;
    y_arr: Array<(number)>;
    z_arr: Array<(number)>;
    poly_id: (number | string);
};

/**
 * To be revisited later when the metadata is more mature.
 */
export type PolygonsAttributeType_api = 'depth' | 'time' | 'property' | 'seismic' | 'thickness' | 'isochore' | 'fluid_contact' | 'field_outline' | 'pinchout' | 'subcrop' | 'fault_lines';

export type PolygonsMeta_api = {
    name: string;
    name_is_stratigraphic_offical: boolean;
    stratigraphic_identifier: (string | null);
    relative_stratigraphic_level: (number | null);
    parent_stratigraphic_identifier: (string | null);
    attribute_name: string;
    attribute_type: PolygonsAttributeType_api;
};

export type PolylineIntersection_api = {
    fence_mesh_sections: Array<FenceMeshSection_api>;
    grid_dimensions: GridDimensions_api;
    min_grid_prop_value: number;
    max_grid_prop_value: number;
};

export type PvtData_api = {
    name: string;
    phase: string;
    pvtnum: number;
    ratio: Array<(number)>;
    pressure: Array<(number)>;
    volumefactor: Array<(number)>;
    viscosity: Array<(number)>;
    density: Array<(number)>;
    pressure_unit: string;
    volumefactor_unit: string;
    viscosity_unit: string;
    density_unit: string;
    ratio_unit: string;
};

/**
 * Data for a single column in a volumetric table
 *
 * Length of index list should be equal to the number of rows in the table
 *
 * - unique_values: List of unique values in the column
 * - indices: List of indices, in unique_values list, for each row in the table
 */
export type RepeatedTableColumnData_api = {
    columnName: string;
    uniqueValues: Array<(string | number)>;
    indices: Array<(number)>;
};

export type RftInfo_api = {
    well_name: string;
    timestamps_utc_ms: Array<(number)>;
};

/**
 * A specific RFT (Repeat Formation Tester) observation.
 *
 * Attributes:
 * value (float): The measured value of the observation.
 * comment (Optional[str]): An optional comment associated with the observation.
 * error (float): The measurement error associated with the observation.
 * zone (str): The zone or region associated with the observation.
 * md_msl (float): Measured depth from mean sea level.
 * x (float): X utm coordinate of the observation.
 * y (float): Y utm coordinate of the observation.
 * z (float): Z utm coordinate of the observation.
 */
export type RftObservation_api = {
    value: number;
    comment: (string | null);
    error: number;
    zone: string;
    md_msl: number;
    x: number;
    y: number;
    z: number;
};

/**
 * A collection of RFT (Repeat Formation Tester) observations for a specific well at a specific date.
 *
 * Attributes:
 * well (str): Unique well identifier
 * date (str): Observation date
 * comment (Optional[str]): An optional comment associated with the collection of observations.
 * observations (List[RftObservation_api]): A list of RFT observations associated with this collection.
 */
export type RftObservations_api = {
    well: string;
    date: string;
    comment: (string | null);
    observations: Array<RftObservation_api>;
};

export type RftRealizationData_api = {
    well_name: string;
    realization: number;
    timestamp_utc_ms: number;
    depth_arr: Array<(number)>;
    value_arr: Array<(number)>;
};

export type SeismicCubeMeta_api = {
    seismic_attribute: string;
    iso_date_or_interval: string;
    is_observation: boolean;
    is_depth: boolean;
};

/**
 * Definition of a fence of seismic data from a set of (x, y) coordinates in domain coordinate system.
 * Each (x, y) point provides a trace perpendicular to the x-y plane, with number of samples equal to the depth of the seismic cube.
 *
 * Each trace is defined to be a set of depth value samples along the length direction of the fence.
 *
 * `Properties:`
 * - `fence_traces_b64arr`: The fence trace array is base64 encoded 1D float array - where data is stored trace by trace.
 * - `num_traces`: The number of traces in the fence trace array. Equals the number of (x, y) coordinates in requested polyline.
 * - `num_samples_per_trace`: The number of samples in each trace.
 * - `min_fence_depth`: The minimum depth value of the fence.
 * - `max_fence_depth`: The maximum depth value of the fence.
 *
 * `Description - fence_traces_b64arr:`
 *
 * The encoded fence trace array is a flattened array of traces, where data is stored trace by trace.
 * With `m = num_traces`, and `n = num_samples_per_trace`, the flattened array has length `mxn`.
 *
 * Fence traces 1D array: [trace_1_sample_1, trace_1_sample_2, ..., trace_1_sample_n, ..., trace_m_sample_1, trace_m_sample_2, ..., trace_m_sample_n]
 *
 *
 * See:
 * - VdsAxis: https://github.com/equinor/vds-slice/blob/ab6f39789bf3d3b59a8df14f1c4682d340dc0bf3/internal/core/core.go#L37-L55
 */
export type SeismicFenceData_api = {
    fence_traces_b64arr: B64FloatArray_api;
    num_traces: number;
    num_samples_per_trace: number;
    min_fence_depth: number;
    max_fence_depth: number;
};

/**
 * (x, y) points defining a polyline in domain coordinate system, to retrieve fence of seismic data.
 *
 * Expect equal number of x- and y-points.
 *
 * Note: Coordinates are in domain coordinate system (UTM).
 *
 * NOTE:
 * - Verify coordinates are in domain coordinate system (UTM)?
 * - Consider points_xy: List[float] - i.e. array with [x1, y1, x2, y2, ..., xn, yn] instead of x_points and y_points arrays?
 * - Ensure equal length of x_points and y_points arrays?
 */
export type SeismicFencePolyline_api = {
    x_points: Array<(number)>;
    y_points: Array<(number)>;
};

export type SensitivityType_api = 'montecarlo' | 'scenario';

export type StatisticFunction_api = 'MEAN' | 'MIN' | 'MAX' | 'P10' | 'P90' | 'P50';

export type StatisticValueObject_api = {
    statistic_function: StatisticFunction_api;
    values: Array<(number)>;
};

/**
 * Stratigraphic unit from SMDA
 *
 * Camel case attributes needed for esvIntersection component in front-end
 */
export type StratigraphicUnit_api = {
    identifier: string;
    top: string;
    base: string;
    stratUnitLevel: number;
    stratUnitType: string;
    topAge: (number);
    baseAge: (number);
    stratUnitParent: (string | null);
    colorR: number;
    colorG: number;
    colorB: number;
    lithologyType: (number | string);
};

/**
 * A single observation of a summary vector at a specific date.
 */
export type SummaryVectorDateObservation_api = {
    date: string;
    comment: (string | null);
    value: number;
    error: number;
    label: string;
};

/**
 * A collection of observations of a summary vector.
 */
export type SummaryVectorObservations_api = {
    vector_name: string;
    comment: (string | null);
    observations: Array<SummaryVectorDateObservation_api>;
};

/**
 * A surface has a single array with values, e.g. depth, time, property, seismic, thickness.
 * Only surfaces with depth and time have z-values that can be plotted in 3D.
 * The other attributes are scalar values that can be plotted in 2D or used as colormapping for 3D surfaces.
 *
 * Ideally if the attribute is a scalar, there should be corresponding z-values, but this information is not
 * available in the metadata.
 *
 * To be revisited later when the metadata is more mature.
 */
export type SurfaceAttributeType_api = 'depth' | 'facies_thickness' | 'fluid_contact' | 'pinchout' | 'property' | 'seismic' | 'subcrop' | 'thickness' | 'time' | 'velocity' | 'volumes' | 'UNKNOWN';

export type SurfaceDataFloat_api = {
    format: "float";
    surface_def: SurfaceDef_api;
    transformed_bbox_utm: BoundingBox2d_api;
    value_min: number;
    value_max: number;
    values_b64arr: B64FloatArray_api;
};

export type SurfaceDataPng_api = {
    format: "png";
    surface_def: SurfaceDef_api;
    transformed_bbox_utm: BoundingBox2d_api;
    value_min: number;
    value_max: number;
    png_image_base64: string;
};

export type SurfaceDef_api = {
    npoints_x: number;
    npoints_y: number;
    inc_x: number;
    inc_y: number;
    origin_utm_x: number;
    origin_utm_y: number;
    rot_deg: number;
};

/**
 * (x, y) points defining a polyline in domain coordinate system, to retrieve intersection of a surface, with a cumulative length
 * between at each (x, y)-point coordinates in domain coordinate system.
 *
 * Expect equal number of x- and y-points.
 *
 * x_points: X-coordinates of polyline points.
 * y_points: Y-coordinates of polyline points.
 * cum_lengths: Cumulative lengths of the polyline segments, i.e. the length of the polyline up to each (x,y) point.
 *
 * The cumulative lengths can be e.g. measured depth along a well path.
 *
 * Note: Coordinates are in domain coordinate system (UTM)
 *
 * Note: Verify if cum_lengths is necessary with respect to xtgeo
 */
export type SurfaceIntersectionCumulativeLengthPolyline_api = {
    x_points: Array<(number)>;
    y_points: Array<(number)>;
    cum_lengths: Array<(number)>;
};

/**
 * Definition of a surface intersection made from a set of (x, y) coordinates.
 *
 * name: Name of the surface
 * z_points: Array of z-points (depth values) at the intersection points, i.e. depth value for each (x,y) point.
 * cum_lengths: Cumulative length values at the intersection points, i.e. accumulated length between each element in the z points.
 */
export type SurfaceIntersectionData_api = {
    name: string;
    z_points: Array<(number)>;
    cum_lengths: Array<(number)>;
};

export type SurfaceMeta_api = {
    name: string;
    name_is_stratigraphic_offical: boolean;
    attribute_name: string;
    attribute_type: SurfaceAttributeType_api;
    time_type: SurfaceTimeType_api;
    is_observation: boolean;
    value_min: (number | null);
    value_max: (number | null);
};

export type SurfaceMetaSet_api = {
    surfaces: Array<SurfaceMeta_api>;
    time_points_iso_str: Array<(string)>;
    time_intervals_iso_str: Array<(string)>;
    surface_names_in_strat_order: Array<(string)>;
};

export type SurfaceRealizationSampleValues_api = {
    realization: number;
    sampled_values: Array<(number)>;
};

export type SurfaceStatisticFunction_api = 'MEAN' | 'STD' | 'MIN' | 'MAX' | 'P10' | 'P90' | 'P50';

export type SurfaceTimeType_api = 'NO_TIME' | 'TIME_POINT' | 'INTERVAL';

/**
 * Data for a single column in a volumetric table
 *
 * Length of column values should be equal to the number of rows in the table
 */
export type TableColumnData_api = {
    columnName: string;
    columnValues: Array<(number)>;
};

/**
 * Statistical data for a single result column in a volumetric table
 *
 * Length of column values should be equal to the number of rows in the table
 */
export type TableColumnStatisticalData_api = {
    columnName: string;
    statisticValues: {
        [key: string]: Array<(number)>;
    };
};

export type TabType_api = 'BHP' | 'TEMP';

export type THP_api = "THP_api";

export type TreeNode_api = {
    node_type_api: 'Group' | 'Well';
    node_label: string;
    edge_label: string;
    node_data: {
        [key: string]: Array<(number)>;
    };
    edge_data: {
        [key: string]: Array<(number)>;
    };
    children: Array<TreeNode_api>;
};

export type node_type_api = 'Group' | 'Well';

export type UnitType_api = 'METRIC' | 'FIELD' | 'LAB' | 'PVT-M' | 'DEFAULT';

export type UserInfo_api = {
    username: string;
    display_name: (string | null);
    avatar_b64str: (string | null);
    has_sumo_access: boolean;
    has_smda_access: boolean;
};

export type ValidationError_api = {
    loc: Array<(string | number)>;
    msg: string;
    type: string;
};

export type VectorDescription_api = {
    name: string;
    descriptive_name: string;
    has_historical: boolean;
};

export type VectorHistoricalData_api = {
    timestamps_utc_ms: Array<(number)>;
    values: Array<(number)>;
    unit: string;
    is_rate: boolean;
};

export type VectorRealizationData_api = {
    realization: number;
    timestamps_utc_ms: Array<(number)>;
    values: Array<(number)>;
    unit: string;
    is_rate: boolean;
};

export type VectorStatisticData_api = {
    realizations: Array<(number)>;
    timestamps_utc_ms: Array<(number)>;
    value_objects: Array<StatisticValueObject_api>;
    unit: string;
    is_rate: boolean;
};

export type VectorStatisticSensitivityData_api = {
    realizations: Array<(number)>;
    timestamps_utc_ms: Array<(number)>;
    value_objects: Array<StatisticValueObject_api>;
    unit: string;
    is_rate: boolean;
    sensitivity_name: string;
    sensitivity_case: string;
};

export type VfpInjTable_api = {
    isInjTable: boolean;
    tableNumber: number;
    datum: number;
    flowRateType: FlowRateType_api;
    unitType: UnitType_api;
    tabType: TabType_api;
    thpValues: Array<(number)>;
    flowRateValues: Array<(number)>;
    bhpValues: Array<(number)>;
    flowRateUnit: string;
    thpUnit: string;
    bhpUnit: string;
};

export type VfpProdTable_api = {
    isProdTable: boolean;
    tableNumber: number;
    datum: number;
    thpType: THP_api;
    wfrType: WFR_api;
    gfrType: GFR_api;
    alqType: ALQ_api;
    flowRateType: FlowRateType_api;
    unitType: UnitType_api;
    tabType: TabType_api;
    thpValues: Array<(number)>;
    wfrValues: Array<(number)>;
    gfrValues: Array<(number)>;
    alqValues: Array<(number)>;
    flowRateValues: Array<(number)>;
    bhpValues: Array<(number)>;
    flowRateUnit: string;
    thpUnit: string;
    wfrUnit: string;
    gfrUnit: string;
    alqUnit: string;
    bhpUnit: string;
};

export type WellboreCasing_api = {
    itemType: string;
    diameterNumeric: number;
    diameterInner: number;
    description: (string | null);
    remark: (string | null);
    depthTopMd: number;
    depthBottomMd: number;
    totalDepthMd: number;
    startDepth: number;
    endDepth: number;
};

export type WellboreCompletion_api = {
    mdTop: number;
    mdBottom: number;
    tvdTop: (number | null);
    tvdBottom: (number | null);
    description: (string | null);
    symbolName: (string | null);
    comment: (string | null);
};

export type WellboreHeader_api = {
    wellboreUuid: string;
    uniqueWellboreIdentifier: string;
    wellUuid: string;
    uniqueWellIdentifier: string;
    wellEasting: number;
    wellNorthing: number;
    depthReferencePoint: string;
    depthReferenceElevation: number;
};

export type WellboreLogCurveData_api = {
    indexMin: number;
    indexMax: number;
    minCurveValue: number;
    maxCurveValue: number;
    dataPoints: Array<Array<(number | null)>>;
    curveAlias: string;
    curveDescription: string;
    indexUnit: string;
    noDataValue: number;
};

export type WellboreLogCurveHeader_api = {
    logName: string;
    curveName: string;
    curveUnit: string;
};

export type WellborePerforation_api = {
    mdTop: number;
    mdBottom: number;
    tvdTop: number;
    tvdBottom: number;
    status: string;
    completionMode: string;
};

/**
 * Wellbore pick from SMDA
 *
 * Camel case attributes needed for esvIntersection component in front-end
 */
export type WellborePick_api = {
    northing: number;
    easting: number;
    tvd: number;
    tvdMsl: number;
    md: number;
    mdMsl: number;
    uniqueWellboreIdentifier: string;
    pickIdentifier: string;
    confidence: (string | null);
    depthReferencePoint: string;
    mdUnit: string;
};

export type WellborePicksAndStratigraphicUnits_api = {
    wellbore_picks: Array<WellborePick_api>;
    stratigraphic_units: Array<StratigraphicUnit_api>;
};

export type WellboreTrajectory_api = {
    wellboreUuid: string;
    uniqueWellboreIdentifier: string;
    tvdMslArr: Array<(number)>;
    mdArr: Array<(number)>;
    eastingArr: Array<(number)>;
    northingArr: Array<(number)>;
};

/**
 * Type definition for well completions data
 */
export type WellCompletionsData_api = {
    version: string;
    units: WellCompletionsUnits_api;
    zones: Array<WellCompletionsZone_api>;
    sortedCompletionDates: Array<(string)>;
    wells: Array<WellCompletionsWell_api>;
};

export type WellCompletionsUnitInfo_api = {
    unit: string;
    decimalPlaces: number;
};

export type WellCompletionsUnits_api = {
    kh: WellCompletionsUnitInfo_api;
};

export type WellCompletionsWell_api = {
    name: string;
    attributes: {
        [key: string]: (string | number | boolean);
    };
    completions: {
        [key: string]: Completions_api;
    };
};

export type WellCompletionsZone_api = {
    name: string;
    subzones: (Array<WellCompletionsZone_api> | null);
};

export type WFR_api = 'WOR' | 'WCT' | 'WGR' | 'WWR' | 'WTF';

export type GetFieldsResponse_api = (Array<FieldInfo_api>);

export type GetFieldsError_api = unknown;

export type GetCasesData_api = {
    query: {
        /**
         * Field identifier
         */
        field_identifier: string;
    };
};

export type GetCasesResponse_api = (Array<CaseInfo_api>);

export type GetCasesError_api = (HTTPValidationError_api);

export type GetEnsemblesData_api = {
    path: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
    };
};

export type GetEnsemblesResponse_api = (Array<EnsembleInfo_api>);

export type GetEnsemblesError_api = (HTTPValidationError_api);

export type GetEnsembleDetailsData_api = {
    path: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetEnsembleDetailsResponse_api = (EnsembleDetails_api);

export type GetEnsembleDetailsError_api = (HTTPValidationError_api);

export type GetVectorListData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetVectorListResponse_api = (Array<VectorDescription_api>);

export type GetVectorListError_api = (HTTPValidationError_api);

export type GetRealizationsVectorDataData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Optional list of realizations to include. If not specified, all realizations will be returned.
         */
        realizations?: (Array<(number)> | null);
        /**
         * Resampling frequency. If not specified, raw data without resampling wil be returned.
         */
        resampling_frequency?: (Frequency_api | null);
        /**
         * Name of the vector
         */
        vector_name: string;
    };
};

export type GetRealizationsVectorDataResponse_api = (Array<VectorRealizationData_api>);

export type GetRealizationsVectorDataError_api = (HTTPValidationError_api);

export type GetTimestampsListData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency?: (Frequency_api | null);
    };
};

export type GetTimestampsListResponse_api = (Array<(number)>);

export type GetTimestampsListError_api = (HTTPValidationError_api);

export type GetHistoricalVectorDataData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Name of the non-historical vector
         */
        non_historical_vector_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency?: (Frequency_api | null);
    };
};

export type GetHistoricalVectorDataResponse_api = (VectorHistoricalData_api);

export type GetHistoricalVectorDataError_api = (HTTPValidationError_api);

export type GetStatisticalVectorDataData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Optional list of realizations to include. If not specified, all realizations will be included.
         */
        realizations?: (Array<(number)> | null);
        /**
         * Resampling frequency
         */
        resampling_frequency: (Frequency_api);
        /**
         * Optional list of statistics to calculate. If not specified, all statistics will be calculated.
         */
        statistic_functions?: (Array<StatisticFunction_api> | null);
        /**
         * Name of the vector
         */
        vector_name: string;
    };
};

export type GetStatisticalVectorDataResponse_api = (VectorStatisticData_api);

export type GetStatisticalVectorDataError_api = (HTTPValidationError_api);

export type GetStatisticalVectorDataPerSensitivityData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency: (Frequency_api);
        /**
         * Optional list of statistics to calculate. If not specified, all statistics will be calculated.
         */
        statistic_functions?: (Array<StatisticFunction_api> | null);
        /**
         * Name of the vector
         */
        vector_name: string;
    };
};

export type GetStatisticalVectorDataPerSensitivityResponse_api = (Array<VectorStatisticSensitivityData_api>);

export type GetStatisticalVectorDataPerSensitivityError_api = (HTTPValidationError_api);

export type GetRealizationVectorAtTimestampData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Timestamp in ms UTC to query vectors at
         */
        timestamp_utc_ms: number;
        /**
         * Name of the vector
         */
        vector_name: string;
    };
};

export type GetRealizationVectorAtTimestampResponse_api = (EnsembleScalarResponse_api);

export type GetRealizationVectorAtTimestampError_api = (HTTPValidationError_api);

export type GetTableDefinitionsData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetTableDefinitionsResponse_api = (Array<InplaceVolumetricsTableDefinition_api>);

export type GetTableDefinitionsError_api = (HTTPValidationError_api);

export type PostGetAggregatedPerRealizationTableDataData_api = {
    body: Body_post_get_aggregated_per_realization_table_data_api;
    query: {
        /**
         * Whether to accumulate fluid zones
         */
        accumulate_fluid_zones: boolean;
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * The fluid zones to aggregate by
         */
        fluid_zones: Array<FluidZone_api>;
        /**
         * The identifiers to group table data by
         */
        group_by_identifiers?: (Array<InplaceVolumetricsIdentifier_api> | null);
        /**
         * Optional list of realizations to include. If not specified, all realizations will be returned.
         */
        realizations?: (Array<(number)> | null);
        /**
         * The name of the volumetric results
         */
        result_names: Array<(string)>;
        /**
         * Table name
         */
        table_name: string;
    };
};

export type PostGetAggregatedPerRealizationTableDataResponse_api = (InplaceVolumetricTableDataPerFluidSelection_api);

export type PostGetAggregatedPerRealizationTableDataError_api = (HTTPValidationError_api);

export type PostGetAggregatedStatisticalTableDataData_api = {
    body: Body_post_get_aggregated_statistical_table_data_api;
    query: {
        /**
         * Whether to accumulate fluid zones
         */
        accumulate_fluid_zones: boolean;
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * The fluid zones to aggregate by
         */
        fluid_zones: Array<FluidZone_api>;
        /**
         * The identifiers to group table data by
         */
        group_by_identifiers?: (Array<InplaceVolumetricsIdentifier_api> | null);
        /**
         * Optional list of realizations to include. If not specified, all realizations will be returned.
         */
        realizations?: (Array<(number)> | null);
        /**
         * The name of the volumetric results
         */
        result_names: Array<(string)>;
        /**
         * Table name
         */
        table_name: string;
    };
};

export type PostGetAggregatedStatisticalTableDataResponse_api = (InplaceStatisticalVolumetricTableDataPerFluidSelection_api);

export type PostGetAggregatedStatisticalTableDataError_api = (HTTPValidationError_api);

export type GetRealizationSurfacesMetadataData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetRealizationSurfacesMetadataResponse_api = (SurfaceMetaSet_api);

export type GetRealizationSurfacesMetadataError_api = (HTTPValidationError_api);

export type GetObservedSurfacesMetadataData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
    };
};

export type GetObservedSurfacesMetadataResponse_api = (SurfaceMetaSet_api);

export type GetObservedSurfacesMetadataError_api = (HTTPValidationError_api);

export type GetSurfaceDataData_api = {
    query: {
        /**
         * Format of binary data in the response
         */
        data_format?: 'float' | 'png';
        /**
         * Definition of the surface onto which the data should be resampled. *SurfaceDef_api* object properties encoded as a `KeyValStr` string.
         */
        resample_to_def_str?: (string | null);
        /**
         * Surface address string, supported address types are *REAL*, *OBS* and *STAT*
         */
        surf_addr_str: string;
    };
};

export type GetSurfaceDataResponse_api = ((SurfaceDataFloat_api | SurfaceDataPng_api));

export type GetSurfaceDataError_api = (HTTPValidationError_api);

export type PostGetSurfaceIntersectionData_api = {
    body: Body_post_get_surface_intersection_api;
    query: {
        /**
         * Surface attribute
         */
        attribute: string;
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Surface name
         */
        name: string;
        /**
         * Realization number
         */
        realization_num: number;
        /**
         * Time point or time interval string
         */
        time_or_interval_str?: (string | null);
    };
};

export type PostGetSurfaceIntersectionResponse_api = (SurfaceIntersectionData_api);

export type PostGetSurfaceIntersectionError_api = (HTTPValidationError_api);

export type PostSampleSurfaceInPointsData_api = {
    body: Body_post_sample_surface_in_points_api;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization numbers
         */
        realization_nums: Array<(number)>;
        /**
         * Surface attribute
         */
        surface_attribute: string;
        /**
         * Surface name
         */
        surface_name: string;
    };
};

export type PostSampleSurfaceInPointsResponse_api = (Array<SurfaceRealizationSampleValues_api>);

export type PostSampleSurfaceInPointsError_api = (HTTPValidationError_api);

export type GetDeltaSurfaceDataData_api = {
    query: {
        /**
         * Format of binary data in the response
         */
        data_format?: 'float' | 'png';
        /**
         * Definition of the surface onto which the data should be resampled. *SurfaceDef_api* object properties encoded as a `KeyValStr` string.
         */
        resample_to_def_str?: (string | null);
        /**
         * Address string of surface A, supported types: *REAL*, *OBS* and *STAT*
         */
        surf_a_addr_str: string;
        /**
         * Address string of surface B, supported types: *REAL*, *OBS* and *STAT*
         */
        surf_b_addr_str: string;
    };
};

export type GetDeltaSurfaceDataResponse_api = (Array<SurfaceDataFloat_api>);

export type GetDeltaSurfaceDataError_api = (HTTPValidationError_api);

export type GetMisfitSurfaceDataData_api = {
    query: {
        /**
         * Format of binary data in the response
         */
        data_format?: 'float' | 'png';
        /**
         * Address of observed surface, only supported address type is *OBS*
         */
        obs_surf_addr_str: string;
        /**
         * Realization numbers
         */
        realizations: Array<(number)>;
        /**
         * Definition of the surface onto which the data should be resampled. *SurfaceDef_api* object properties encoded as a `KeyValStr` string.
         */
        resample_to_def_str?: (string | null);
        /**
         * Address of simulated surface, supported type is *PARTIAL*
         */
        sim_surf_addr_str: string;
        /**
         * Statistics to calculate
         */
        statistic_functions: Array<SurfaceStatisticFunction_api>;
    };
};

export type GetMisfitSurfaceDataResponse_api = (Array<SurfaceDataFloat_api>);

export type GetMisfitSurfaceDataError_api = (HTTPValidationError_api);

export type GetParameterNamesAndDescriptionData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Exclude all parameters where all values are the same value
         */
        exclude_all_values_constant?: boolean;
        /**
         * Sort order
         */
        sort_order?: 'alphabetically' | 'standard_deviation';
    };
};

export type GetParameterNamesAndDescriptionResponse_api = (Array<EnsembleParameterDescription_api>);

export type GetParameterNamesAndDescriptionError_api = (HTTPValidationError_api);

export type GetParameterData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Parameter name
         */
        parameter_name: string;
    };
};

export type GetParameterResponse_api = ((EnsembleParameter_api | null));

export type GetParameterError_api = (HTTPValidationError_api);

export type GetParametersData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetParametersResponse_api = (Array<EnsembleParameter_api>);

export type GetParametersError_api = (HTTPValidationError_api);

export type IsSensitivityRunData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type IsSensitivityRunResponse_api = (boolean);

export type IsSensitivityRunError_api = (HTTPValidationError_api);

export type GetSensitivitiesData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetSensitivitiesResponse_api = (Array<EnsembleSensitivity_api>);

export type GetSensitivitiesError_api = (HTTPValidationError_api);

export type GetGridModelsInfoData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization
         */
        realization_num: number;
    };
};

export type GetGridModelsInfoResponse_api = (Array<Grid3dInfo_api>);

export type GetGridModelsInfoError_api = (HTTPValidationError_api);

export type IsGridGeometrySharedData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
    };
};

export type IsGridGeometrySharedResponse_api = (boolean);

export type IsGridGeometrySharedError_api = (HTTPValidationError_api);

export type GridSurfaceData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
        /**
         * Max i index
         */
        i_max?: number;
        /**
         * Min i index
         */
        i_min?: number;
        /**
         * Max j index
         */
        j_max?: number;
        /**
         * Min j index
         */
        j_min?: number;
        /**
         * Max k index
         */
        k_max?: number;
        /**
         * Min k index
         */
        k_min?: number;
        /**
         * Realization
         */
        realization_num: number;
    };
};

export type GridSurfaceResponse_api = (Grid3dGeometry_api);

export type GridSurfaceError_api = (HTTPValidationError_api);

export type GridParameterData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
        /**
         * Max i index
         */
        i_max?: number;
        /**
         * Min i index
         */
        i_min?: number;
        /**
         * Max j index
         */
        j_max?: number;
        /**
         * Min j index
         */
        j_min?: number;
        /**
         * Max k index
         */
        k_max?: number;
        /**
         * Min k index
         */
        k_min?: number;
        /**
         * Grid parameter
         */
        parameter_name: string;
        /**
         * Time point or time interval string
         */
        parameter_time_or_interval_str?: (string | null);
        /**
         * Realization
         */
        realization_num: number;
    };
};

export type GridParameterResponse_api = (Grid3dMappedProperty_api);

export type GridParameterError_api = (HTTPValidationError_api);

export type PostGetPolylineIntersectionData_api = {
    body: Body_post_get_polyline_intersection_api;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
        /**
         * Grid parameter
         */
        parameter_name: string;
        /**
         * Time point or time interval string
         */
        parameter_time_or_interval_str?: (string | null);
        /**
         * Realization
         */
        realization_num: number;
    };
};

export type PostGetPolylineIntersectionResponse_api = (PolylineIntersection_api);

export type PostGetPolylineIntersectionError_api = (HTTPValidationError_api);

export type GetRealizationGroupTreeDataData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Node types
         */
        node_type_set: Array<NodeType_api>;
        /**
         * Realization
         */
        realization: number;
        /**
         * Resampling frequency
         */
        resampling_frequency: (Frequency_api);
    };
};

export type GetRealizationGroupTreeDataResponse_api = (GroupTreeData_api);

export type GetRealizationGroupTreeDataError_api = (HTTPValidationError_api);

export type TableDataData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization number
         */
        realization: number;
    };
};

export type TableDataResponse_api = (Array<PvtData_api>);

export type TableDataError_api = (HTTPValidationError_api);

export type RealizationsTablesAreEqualData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type RealizationsTablesAreEqualResponse_api = (boolean);

export type RealizationsTablesAreEqualError_api = (HTTPValidationError_api);

export type GetWellCompletionsDataData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Optional realizations to include. Provide single realization or list of realizations. If not specified, all realizations will be returned.
         */
        realization?: (number | Array<(number)> | null);
    };
};

export type GetWellCompletionsDataResponse_api = (WellCompletionsData_api);

export type GetWellCompletionsDataError_api = (HTTPValidationError_api);

export type GetDrilledWellboreHeadersData_api = {
    query: {
        /**
         * Sumo field identifier
         */
        field_identifier: string;
    };
};

export type GetDrilledWellboreHeadersResponse_api = (Array<WellboreHeader_api>);

export type GetDrilledWellboreHeadersError_api = (HTTPValidationError_api);

export type GetFieldWellTrajectoriesData_api = {
    query: {
        /**
         * Sumo field identifier
         */
        field_identifier: string;
        /**
         * Optional subset of well names
         */
        unique_wellbore_identifiers?: Array<(string)>;
    };
};

export type GetFieldWellTrajectoriesResponse_api = (Array<WellboreTrajectory_api>);

export type GetFieldWellTrajectoriesError_api = (HTTPValidationError_api);

export type GetWellTrajectoriesData_api = {
    query: {
        /**
         * Wellbore uuids
         */
        wellbore_uuids: Array<(string)>;
    };
};

export type GetWellTrajectoriesResponse_api = (Array<WellboreTrajectory_api>);

export type GetWellTrajectoriesError_api = (HTTPValidationError_api);

export type GetWellborePicksAndStratigraphicUnitsData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetWellborePicksAndStratigraphicUnitsResponse_api = (WellborePicksAndStratigraphicUnits_api);

export type GetWellborePicksAndStratigraphicUnitsError_api = (HTTPValidationError_api);

export type GetWellboreCompletionsData_api = {
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetWellboreCompletionsResponse_api = (Array<WellboreCompletion_api>);

export type GetWellboreCompletionsError_api = (HTTPValidationError_api);

export type GetWellboreCasingsData_api = {
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetWellboreCasingsResponse_api = (Array<WellboreCasing_api>);

export type GetWellboreCasingsError_api = (HTTPValidationError_api);

export type GetWellborePerforationsData_api = {
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetWellborePerforationsResponse_api = (Array<WellborePerforation_api>);

export type GetWellborePerforationsError_api = (HTTPValidationError_api);

export type GetWellboreLogCurveHeadersData_api = {
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetWellboreLogCurveHeadersResponse_api = (Array<WellboreLogCurveHeader_api>);

export type GetWellboreLogCurveHeadersError_api = (HTTPValidationError_api);

export type GetLogCurveDataData_api = {
    query: {
        /**
         * Log curve name
         */
        log_curve_name: string;
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetLogCurveDataResponse_api = (WellboreLogCurveData_api);

export type GetLogCurveDataError_api = (HTTPValidationError_api);

export type GetSeismicCubeMetaListData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetSeismicCubeMetaListResponse_api = (Array<SeismicCubeMeta_api>);

export type GetSeismicCubeMetaListError_api = (HTTPValidationError_api);

export type PostGetSeismicFenceData_api = {
    body: Body_post_get_seismic_fence_api;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Observed or simulated
         */
        observed: boolean;
        /**
         * Realization number
         */
        realization_num: number;
        /**
         * Seismic cube attribute
         */
        seismic_attribute: string;
        /**
         * Timestamp or timestep
         */
        time_or_interval_str: string;
    };
};

export type PostGetSeismicFenceResponse_api = (SeismicFenceData_api);

export type PostGetSeismicFenceError_api = (HTTPValidationError_api);

export type GetPolygonsDirectoryData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetPolygonsDirectoryResponse_api = (Array<PolygonsMeta_api>);

export type GetPolygonsDirectoryError_api = (HTTPValidationError_api);

export type GetPolygonsDataData_api = {
    query: {
        /**
         * Surface attribute
         */
        attribute: string;
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Surface name
         */
        name: string;
        /**
         * Realization number
         */
        realization_num: number;
    };
};

export type GetPolygonsDataResponse_api = (Array<PolygonData_api>);

export type GetPolygonsDataError_api = (HTTPValidationError_api);

export type UserInfoData_api = {
    query: {
        /**
         * User id
         */
        user_id: string;
    };
};

export type UserInfoResponse_api = (GraphUserPhoto_api);

export type UserInfoError_api = (HTTPValidationError_api);

export type GetObservationsData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
    };
};

export type GetObservationsResponse_api = (Observations_api);

export type GetObservationsError_api = (HTTPValidationError_api);

export type GetRftInfoData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetRftInfoResponse_api = (Array<RftInfo_api>);

export type GetRftInfoError_api = (HTTPValidationError_api);

export type GetRealizationDataData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realizations
         */
        realizations?: (Array<(number)> | null);
        /**
         * Response name
         */
        response_name: string;
        /**
         * Timestamps utc ms
         */
        timestamps_utc_ms?: (Array<(number)> | null);
        /**
         * Well name
         */
        well_name: string;
    };
};

export type GetRealizationDataResponse_api = (Array<RftRealizationData_api>);

export type GetRealizationDataError_api = (HTTPValidationError_api);

export type GetVfpTableNamesData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization
         */
        realization: number;
    };
};

export type GetVfpTableNamesResponse_api = (Array<(string)>);

export type GetVfpTableNamesError_api = (HTTPValidationError_api);

export type GetVfpTableData_api = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization
         */
        realization: number;
        /**
         * VFP table name
         */
        vfp_table_name: string;
    };
};

export type GetVfpTableResponse_api = ((VfpProdTable_api | VfpInjTable_api));

export type GetVfpTableError_api = (HTTPValidationError_api);

export type LoginRouteData_api = {
    query?: {
        redirect_url_after_login?: (string | null);
    };
};

export type LoginRouteResponse_api = (unknown);

export type LoginRouteError_api = (HTTPValidationError_api);

export type AuthorizedCallbackRouteResponse_api = (unknown);

export type AuthorizedCallbackRouteError_api = unknown;

export type AliveResponse_api = (string);

export type AliveError_api = unknown;

export type AliveProtectedResponse_api = (string);

export type AliveProtectedError_api = unknown;

export type LoggedInUserData_api = {
    query?: {
        /**
         * Set to true to include user avatar and display name from Microsoft Graph API
         */
        includeGraphApiInfo?: boolean;
    };
};

export type LoggedInUserResponse_api = (UserInfo_api);

export type LoggedInUserError_api = (HTTPValidationError_api);

export type RootResponse_api = (string);

export type RootError_api = unknown;