// This file is auto-generated by @hey-api/openapi-ts

export type ALQ = 'GRAT' | 'IGLR' | 'TGLR' | 'PUMP' | 'COMP' | 'DENO' | 'DENG' | 'BEAN' | "''";

export type B64FloatArray = {
    element_type: 'float32' | 'float64';
    data_b64str: string;
};

export type element_type = 'float32' | 'float64';

export type B64UintArray = {
    element_type: 'uint8' | 'uint16' | 'uint32' | 'uint64';
    data_b64str: string;
};

export type element_type2 = 'uint8' | 'uint16' | 'uint32' | 'uint64';

export type Body_post_get_aggregated_per_realization_table_data = {
    /**
     * Selected identifiers and wanted values
     */
    identifiers_with_values: Array<InplaceVolumetricsIdentifierWithValues>;
};

export type Body_post_get_aggregated_statistical_table_data = {
    /**
     * Selected identifiers and wanted values
     */
    identifiers_with_values: Array<InplaceVolumetricsIdentifierWithValues>;
};

export type Body_post_get_polyline_intersection = {
    polyline_utm_xy: Array<(number)>;
};

export type Body_post_get_seismic_fence = {
    polyline: SeismicFencePolyline;
};

export type Body_post_get_surface_intersection = {
    cumulative_length_polyline: SurfaceIntersectionCumulativeLengthPolyline;
};

export type Body_post_sample_surface_in_points = {
    sample_points: PointSetXY;
};

export type BoundingBox2d = {
    min_x: number;
    min_y: number;
    max_x: number;
    max_y: number;
};

/**
 * Bounding box for a 3D grid geometry
 */
export type BoundingBox3d = {
    xmin: number;
    ymin: number;
    zmin: number;
    xmax: number;
    ymax: number;
    zmax: number;
};

export type CaseInfo = {
    uuid: string;
    name: string;
    status: string;
    user: string;
};

export type Completions = {
    sortedCompletionDateIndices: Array<(number)>;
    open: Array<(number)>;
    shut: Array<(number)>;
    khMean: Array<(number)>;
    khMin: Array<(number)>;
    khMax: Array<(number)>;
};

export type DatedTree = {
    dates: Array<(string)>;
    tree: TreeNode;
};

export type EnsembleDetails = {
    name: string;
    field_identifier: string;
    case_name: string;
    case_uuid: string;
    realizations: Array<(number)>;
};

export type EnsembleInfo = {
    name: string;
    realization_count: number;
};

/**
 * Description/data for a single parameter in an ensemble
 */
export type EnsembleParameter = {
    name: string;
    is_logarithmic: boolean;
    is_numerical: boolean;
    is_constant: boolean;
    group_name: (string | null);
    descriptive_name: (string | null);
    realizations: Array<(number)>;
    values: (Array<(number)> | Array<(string)>);
};

export type EnsembleParameterDescription = {
    name: string;
    group_name: (string | null);
    descriptive_name: (string | null);
    is_numerical: boolean;
};

/**
 * A generic type for a scalar response from each of the members of the ensemble.
 */
export type EnsembleScalarResponse = {
    realizations: Array<(number)>;
    values: Array<(number)>;
    name: (string | null);
    unit: (string | null);
};

/**
 * Description/data for a single sensitivity in an ensemble
 */
export type EnsembleSensitivity = {
    name: string;
    type: SensitivityType;
    cases: Array<EnsembleSensitivityCase>;
};

/**
 * Description/data for a single sensitivity case in an ensemble
 */
export type EnsembleSensitivityCase = {
    name: string;
    realizations: Array<(number)>;
};

export type FenceMeshSection = {
    vertices_uz_b64arr: B64FloatArray;
    poly_indices_b64arr: B64UintArray;
    vertices_per_poly_b64arr: B64UintArray;
    poly_source_cell_indices_b64arr: B64UintArray;
    poly_props_b64arr: B64FloatArray;
    start_utm_x: number;
    start_utm_y: number;
    end_utm_x: number;
    end_utm_y: number;
};

export type FieldInfo = {
    field_identifier: string;
};

export type FlowRateType = 'OIL' | 'LIQ' | 'GAS' | 'WG' | 'TM' | 'WAT';

export type FluidZone = 'Oil' | 'Gas' | 'Water';

export type Frequency = 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'QUARTERLY' | 'YEARLY';

export type GFR = 'GOR' | 'GLR' | 'OGR' | 'MMW';

export type GraphUserPhoto = {
    avatar_b64str: (string | null);
};

/**
 * Specification of a 3D grid dimensions
 */
export type Grid3dDimensions = {
    i_count: number;
    j_count: number;
    k_count: number;
    subgrids: Array<Grid3dZone>;
};

export type Grid3dGeometry = {
    polys_b64arr: B64UintArray;
    points_b64arr: B64FloatArray;
    poly_source_cell_indices_b64arr: B64UintArray;
    origin_utm_x: number;
    origin_utm_y: number;
    xmin: number;
    xmax: number;
    ymin: number;
    ymax: number;
    zmin: number;
    zmax: number;
};

/**
 * Metadata for a 3D grid model, including its properties and geometry
 */
export type Grid3dInfo = {
    grid_name: string;
    bbox: BoundingBox3d;
    dimensions: Grid3dDimensions;
    property_info_arr: Array<Grid3dPropertyInfo>;
};

export type Grid3dMappedProperty = {
    poly_props_b64arr: B64FloatArray;
    min_grid_prop_value: number;
    max_grid_prop_value: number;
};

/**
 * Metadata for a 3D grid property
 */
export type Grid3dPropertyInfo = {
    property_name: string;
    iso_date_or_interval: (string | null);
};

/**
 * Named subset of 3D grid layers (Zone)
 */
export type Grid3dZone = {
    name: string;
    start_layer: number;
    end_layer: number;
};

export type GridDimensions = {
    i_count: number;
    j_count: number;
    k_count: number;
};

export type GroupTreeData = {
    edge_metadata_list: Array<GroupTreeMetadata>;
    node_metadata_list: Array<GroupTreeMetadata>;
    dated_trees: Array<DatedTree>;
};

export type GroupTreeMetadata = {
    key: string;
    label: string;
};

export type HTTPValidationError = {
    detail?: Array<ValidationError>;
};

/**
 * Statistical volumetric data for single volume table
 *
 * Contains data for a single fluid zone, e.g. Oil, Gas, Water, or sum of fluid zones
 */
export type InplaceStatisticalVolumetricTableData = {
    fluidSelectionName: string;
    selectorColumns: Array<RepeatedTableColumnData>;
    resultColumnStatistics: Array<TableColumnStatisticalData>;
};

/**
 * Statistical volumetric data for a single table per fluid selection
 *
 * Fluid selection can be single fluid zones, e.g. Oil, Gas, Water, or sum of fluid zones - Oil + Gas + Water
 */
export type InplaceStatisticalVolumetricTableDataPerFluidSelection = {
    tableDataPerFluidSelection: Array<InplaceStatisticalVolumetricTableData>;
};

/**
 * Allowed volumetric response names
 */
export type InplaceVolumetricResultName = 'BULK' | 'NET' | 'PORO' | 'PORO_NET' | 'PORV' | 'HCPV' | 'STOIIP' | 'GIIP' | 'NTG' | 'ASSOCIATEDGAS' | 'ASSOCIATEDOIL' | 'BO' | 'BG' | 'SW' | 'STOIIP_TOTAL' | 'GIIP_TOTAL';

/**
 * Definition of possible statistics for a result column in an inplace volumetrics table
 */
export type InplaceVolumetricStatistic = 'mean' | 'stddev' | 'max' | 'min' | 'p10' | 'p90';

/**
 * Volumetric data for a single table
 *
 * Contains data for a single fluid zone, e.g. Oil, Gas, Water, or sum of fluid zones
 */
export type InplaceVolumetricTableData = {
    fluidSelectionName: string;
    selectorColumns: Array<RepeatedTableColumnData>;
    resultColumns: Array<TableColumnData>;
};

/**
 * Volumetric data for a single table per fluid selection
 *
 * Fluid selection can be single fluid zones, e.g. Oil, Gas, Water, or sum of fluid zones - Oil + Gas + Water
 */
export type InplaceVolumetricTableDataPerFluidSelection = {
    tableDataPerFluidSelection: Array<InplaceVolumetricTableData>;
};

export type InplaceVolumetricsIdentifier = 'ZONE' | 'REGION' | 'FACIES' | 'LICENSE';

/**
 * Unique values for an index column in a volumetric table
 * All values should ideally be strings, but it is common to see integers, especially for REGION
 */
export type InplaceVolumetricsIdentifierWithValues = {
    identifier: InplaceVolumetricsIdentifier;
    values: Array<(string | number)>;
};

/**
 * Definition of a volumetric table
 */
export type InplaceVolumetricsTableDefinition = {
    tableName: string;
    fluidZones: Array<FluidZone>;
    resultNames: Array<InplaceVolumetricResultName>;
    identifiersWithValues: Array<InplaceVolumetricsIdentifierWithValues>;
};

export type NodeType = 'prod' | 'inj' | 'other';

/**
 * A collection of observations associated with a field/case/ensemble
 */
export type Observations = {
    summary: Array<SummaryVectorObservations>;
    rft: Array<RftObservations>;
};

export type PointSetXY = {
    x_points: Array<(number)>;
    y_points: Array<(number)>;
};

export type PolygonData = {
    x_arr: Array<(number)>;
    y_arr: Array<(number)>;
    z_arr: Array<(number)>;
    poly_id: (number | string);
};

/**
 * To be revisited later when the metadata is more mature.
 */
export type PolygonsAttributeType = 'depth' | 'time' | 'property' | 'seismic' | 'thickness' | 'isochore' | 'fluid_contact' | 'field_outline' | 'pinchout' | 'subcrop' | 'fault_lines';

export type PolygonsMeta = {
    name: string;
    name_is_stratigraphic_offical: boolean;
    stratigraphic_identifier: (string | null);
    relative_stratigraphic_level: (number | null);
    parent_stratigraphic_identifier: (string | null);
    attribute_name: string;
    attribute_type: PolygonsAttributeType;
};

export type PolylineIntersection = {
    fence_mesh_sections: Array<FenceMeshSection>;
    grid_dimensions: GridDimensions;
    min_grid_prop_value: number;
    max_grid_prop_value: number;
};

export type PvtData = {
    name: string;
    phase: string;
    pvtnum: number;
    ratio: Array<(number)>;
    pressure: Array<(number)>;
    volumefactor: Array<(number)>;
    viscosity: Array<(number)>;
    density: Array<(number)>;
    pressure_unit: string;
    volumefactor_unit: string;
    viscosity_unit: string;
    density_unit: string;
    ratio_unit: string;
};

/**
 * Data for a single column in a volumetric table
 *
 * Length of index list should be equal to the number of rows in the table
 *
 * - unique_values: List of unique values in the column
 * - indices: List of indices, in unique_values list, for each row in the table
 */
export type RepeatedTableColumnData = {
    columnName: string;
    uniqueValues: Array<(string | number)>;
    indices: Array<(number)>;
};

export type RftInfo = {
    well_name: string;
    timestamps_utc_ms: Array<(number)>;
};

/**
 * A specific RFT (Repeat Formation Tester) observation.
 *
 * Attributes:
 * value (float): The measured value of the observation.
 * comment (Optional[str]): An optional comment associated with the observation.
 * error (float): The measurement error associated with the observation.
 * zone (str): The zone or region associated with the observation.
 * md_msl (float): Measured depth from mean sea level.
 * x (float): X utm coordinate of the observation.
 * y (float): Y utm coordinate of the observation.
 * z (float): Z utm coordinate of the observation.
 */
export type RftObservation = {
    value: number;
    comment: (string | null);
    error: number;
    zone: string;
    md_msl: number;
    x: number;
    y: number;
    z: number;
};

/**
 * A collection of RFT (Repeat Formation Tester) observations for a specific well at a specific date.
 *
 * Attributes:
 * well (str): Unique well identifier
 * date (str): Observation date
 * comment (Optional[str]): An optional comment associated with the collection of observations.
 * observations (List[RftObservation]): A list of RFT observations associated with this collection.
 */
export type RftObservations = {
    well: string;
    date: string;
    comment: (string | null);
    observations: Array<RftObservation>;
};

export type RftRealizationData = {
    well_name: string;
    realization: number;
    timestamp_utc_ms: number;
    depth_arr: Array<(number)>;
    value_arr: Array<(number)>;
};

export type SeismicCubeMeta = {
    seismic_attribute: string;
    iso_date_or_interval: string;
    is_observation: boolean;
    is_depth: boolean;
};

/**
 * Definition of a fence of seismic data from a set of (x, y) coordinates in domain coordinate system.
 * Each (x, y) point provides a trace perpendicular to the x-y plane, with number of samples equal to the depth of the seismic cube.
 *
 * Each trace is defined to be a set of depth value samples along the length direction of the fence.
 *
 * `Properties:`
 * - `fence_traces_b64arr`: The fence trace array is base64 encoded 1D float array - where data is stored trace by trace.
 * - `num_traces`: The number of traces in the fence trace array. Equals the number of (x, y) coordinates in requested polyline.
 * - `num_samples_per_trace`: The number of samples in each trace.
 * - `min_fence_depth`: The minimum depth value of the fence.
 * - `max_fence_depth`: The maximum depth value of the fence.
 *
 * `Description - fence_traces_b64arr:`
 *
 * The encoded fence trace array is a flattened array of traces, where data is stored trace by trace.
 * With `m = num_traces`, and `n = num_samples_per_trace`, the flattened array has length `mxn`.
 *
 * Fence traces 1D array: [trace_1_sample_1, trace_1_sample_2, ..., trace_1_sample_n, ..., trace_m_sample_1, trace_m_sample_2, ..., trace_m_sample_n]
 *
 *
 * See:
 * - VdsAxis: https://github.com/equinor/vds-slice/blob/ab6f39789bf3d3b59a8df14f1c4682d340dc0bf3/internal/core/core.go#L37-L55
 */
export type SeismicFenceData = {
    fence_traces_b64arr: B64FloatArray;
    num_traces: number;
    num_samples_per_trace: number;
    min_fence_depth: number;
    max_fence_depth: number;
};

/**
 * (x, y) points defining a polyline in domain coordinate system, to retrieve fence of seismic data.
 *
 * Expect equal number of x- and y-points.
 *
 * Note: Coordinates are in domain coordinate system (UTM).
 *
 * NOTE:
 * - Verify coordinates are in domain coordinate system (UTM)?
 * - Consider points_xy: List[float] - i.e. array with [x1, y1, x2, y2, ..., xn, yn] instead of x_points and y_points arrays?
 * - Ensure equal length of x_points and y_points arrays?
 */
export type SeismicFencePolyline = {
    x_points: Array<(number)>;
    y_points: Array<(number)>;
};

export type SensitivityType = 'montecarlo' | 'scenario';

export type StatisticFunction = 'MEAN' | 'MIN' | 'MAX' | 'P10' | 'P90' | 'P50';

export type StatisticValueObject = {
    statistic_function: StatisticFunction;
    values: Array<(number)>;
};

/**
 * Stratigraphic unit from SMDA
 *
 * Camel case attributes needed for esvIntersection component in front-end
 */
export type StratigraphicUnit = {
    identifier: string;
    top: string;
    base: string;
    stratUnitLevel: number;
    stratUnitType: string;
    topAge: (number);
    baseAge: (number);
    stratUnitParent: (string | null);
    colorR: number;
    colorG: number;
    colorB: number;
    lithologyType: (number | string);
};

/**
 * A single observation of a summary vector at a specific date.
 */
export type SummaryVectorDateObservation = {
    date: string;
    comment: (string | null);
    value: number;
    error: number;
    label: string;
};

/**
 * A collection of observations of a summary vector.
 */
export type SummaryVectorObservations = {
    vector_name: string;
    comment: (string | null);
    observations: Array<SummaryVectorDateObservation>;
};

/**
 * A surface has a single array with values, e.g. depth, time, property, seismic, thickness.
 * Only surfaces with depth and time have z-values that can be plotted in 3D.
 * The other attributes are scalar values that can be plotted in 2D or used as colormapping for 3D surfaces.
 *
 * Ideally if the attribute is a scalar, there should be corresponding z-values, but this information is not
 * available in the metadata.
 *
 * To be revisited later when the metadata is more mature.
 */
export type SurfaceAttributeType = 'depth' | 'facies_thickness' | 'fluid_contact' | 'pinchout' | 'property' | 'seismic' | 'subcrop' | 'thickness' | 'time' | 'velocity' | 'volumes' | 'UNKNOWN';

export type SurfaceDataFloat = {
    format: "float";
    surface_def: SurfaceDef;
    transformed_bbox_utm: BoundingBox2d;
    value_min: number;
    value_max: number;
    values_b64arr: B64FloatArray;
};

export type SurfaceDataPng = {
    format: "png";
    surface_def: SurfaceDef;
    transformed_bbox_utm: BoundingBox2d;
    value_min: number;
    value_max: number;
    png_image_base64: string;
};

export type SurfaceDef = {
    npoints_x: number;
    npoints_y: number;
    inc_x: number;
    inc_y: number;
    origin_utm_x: number;
    origin_utm_y: number;
    rot_deg: number;
};

/**
 * (x, y) points defining a polyline in domain coordinate system, to retrieve intersection of a surface, with a cumulative length
 * between at each (x, y)-point coordinates in domain coordinate system.
 *
 * Expect equal number of x- and y-points.
 *
 * x_points: X-coordinates of polyline points.
 * y_points: Y-coordinates of polyline points.
 * cum_lengths: Cumulative lengths of the polyline segments, i.e. the length of the polyline up to each (x,y) point.
 *
 * The cumulative lengths can be e.g. measured depth along a well path.
 *
 * Note: Coordinates are in domain coordinate system (UTM)
 *
 * Note: Verify if cum_lengths is necessary with respect to xtgeo
 */
export type SurfaceIntersectionCumulativeLengthPolyline = {
    x_points: Array<(number)>;
    y_points: Array<(number)>;
    cum_lengths: Array<(number)>;
};

/**
 * Definition of a surface intersection made from a set of (x, y) coordinates.
 *
 * name: Name of the surface
 * z_points: Array of z-points (depth values) at the intersection points, i.e. depth value for each (x,y) point.
 * cum_lengths: Cumulative length values at the intersection points, i.e. accumulated length between each element in the z points.
 */
export type SurfaceIntersectionData = {
    name: string;
    z_points: Array<(number)>;
    cum_lengths: Array<(number)>;
};

export type SurfaceMeta = {
    name: string;
    name_is_stratigraphic_offical: boolean;
    attribute_name: string;
    attribute_type: SurfaceAttributeType;
    time_type: SurfaceTimeType;
    is_observation: boolean;
    value_min: (number | null);
    value_max: (number | null);
};

export type SurfaceMetaSet = {
    surfaces: Array<SurfaceMeta>;
    time_points_iso_str: Array<(string)>;
    time_intervals_iso_str: Array<(string)>;
    surface_names_in_strat_order: Array<(string)>;
};

export type SurfaceRealizationSampleValues = {
    realization: number;
    sampled_values: Array<(number)>;
};

export type SurfaceStatisticFunction = 'MEAN' | 'STD' | 'MIN' | 'MAX' | 'P10' | 'P90' | 'P50';

export type SurfaceTimeType = 'NO_TIME' | 'TIME_POINT' | 'INTERVAL';

export type THP = "THP";

export type TabType = 'BHP' | 'TEMP';

/**
 * Data for a single column in a volumetric table
 *
 * Length of column values should be equal to the number of rows in the table
 */
export type TableColumnData = {
    columnName: string;
    columnValues: Array<(number)>;
};

/**
 * Statistical data for a single result column in a volumetric table
 *
 * Length of column values should be equal to the number of rows in the table
 */
export type TableColumnStatisticalData = {
    columnName: string;
    statisticValues: {
        [key: string]: Array<(number)>;
    };
};

export type TreeNode = {
    node_type: 'Group' | 'Well';
    node_label: string;
    edge_label: string;
    node_data: {
        [key: string]: Array<(number)>;
    };
    edge_data: {
        [key: string]: Array<(number)>;
    };
    children: Array<TreeNode>;
};

export type node_type = 'Group' | 'Well';

export type UnitType = 'METRIC' | 'FIELD' | 'LAB' | 'PVT-M' | 'DEFAULT';

export type UserInfo = {
    username: string;
    display_name: (string | null);
    avatar_b64str: (string | null);
    has_sumo_access: boolean;
    has_smda_access: boolean;
};

export type ValidationError = {
    loc: Array<(string | number)>;
    msg: string;
    type: string;
};

export type VectorDescription = {
    name: string;
    descriptive_name: string;
    has_historical: boolean;
};

export type VectorHistoricalData = {
    timestamps_utc_ms: Array<(number)>;
    values: Array<(number)>;
    unit: string;
    is_rate: boolean;
};

export type VectorRealizationData = {
    realization: number;
    timestamps_utc_ms: Array<(number)>;
    values: Array<(number)>;
    unit: string;
    is_rate: boolean;
};

export type VectorStatisticData = {
    realizations: Array<(number)>;
    timestamps_utc_ms: Array<(number)>;
    value_objects: Array<StatisticValueObject>;
    unit: string;
    is_rate: boolean;
};

export type VectorStatisticSensitivityData = {
    realizations: Array<(number)>;
    timestamps_utc_ms: Array<(number)>;
    value_objects: Array<StatisticValueObject>;
    unit: string;
    is_rate: boolean;
    sensitivity_name: string;
    sensitivity_case: string;
};

export type VfpInjTable = {
    isInjTable: boolean;
    tableNumber: number;
    datum: number;
    flowRateType: FlowRateType;
    unitType: UnitType;
    tabType: TabType;
    thpValues: Array<(number)>;
    flowRateValues: Array<(number)>;
    bhpValues: Array<(number)>;
    flowRateUnit: string;
    thpUnit: string;
    bhpUnit: string;
};

export type VfpProdTable = {
    isProdTable: boolean;
    tableNumber: number;
    datum: number;
    thpType: THP;
    wfrType: WFR;
    gfrType: GFR;
    alqType: ALQ;
    flowRateType: FlowRateType;
    unitType: UnitType;
    tabType: TabType;
    thpValues: Array<(number)>;
    wfrValues: Array<(number)>;
    gfrValues: Array<(number)>;
    alqValues: Array<(number)>;
    flowRateValues: Array<(number)>;
    bhpValues: Array<(number)>;
    flowRateUnit: string;
    thpUnit: string;
    wfrUnit: string;
    gfrUnit: string;
    alqUnit: string;
    bhpUnit: string;
};

export type WFR = 'WOR' | 'WCT' | 'WGR' | 'WWR' | 'WTF';

/**
 * Type definition for well completions data
 */
export type WellCompletionsData = {
    version: string;
    units: WellCompletionsUnits;
    zones: Array<WellCompletionsZone>;
    sortedCompletionDates: Array<(string)>;
    wells: Array<WellCompletionsWell>;
};

export type WellCompletionsUnitInfo = {
    unit: string;
    decimalPlaces: number;
};

export type WellCompletionsUnits = {
    kh: WellCompletionsUnitInfo;
};

export type WellCompletionsWell = {
    name: string;
    attributes: {
        [key: string]: (string | number | boolean);
    };
    completions: {
        [key: string]: Completions;
    };
};

export type WellCompletionsZone = {
    name: string;
    subzones: (Array<WellCompletionsZone> | null);
};

export type WellboreCasing = {
    itemType: string;
    diameterNumeric: number;
    diameterInner: number;
    description: (string | null);
    remark: (string | null);
    depthTopMd: number;
    depthBottomMd: number;
    totalDepthMd: number;
    startDepth: number;
    endDepth: number;
};

export type WellboreCompletion = {
    mdTop: number;
    mdBottom: number;
    tvdTop: (number | null);
    tvdBottom: (number | null);
    description: (string | null);
    symbolName: (string | null);
    comment: (string | null);
};

export type WellboreHeader = {
    wellboreUuid: string;
    uniqueWellboreIdentifier: string;
    wellUuid: string;
    uniqueWellIdentifier: string;
    wellEasting: number;
    wellNorthing: number;
    depthReferencePoint: string;
    depthReferenceElevation: number;
};

export type WellboreLogCurveData = {
    indexMin: number;
    indexMax: number;
    minCurveValue: number;
    maxCurveValue: number;
    dataPoints: Array<Array<(number | null)>>;
    curveAlias: string;
    curveDescription: string;
    indexUnit: string;
    noDataValue: number;
};

export type WellboreLogCurveHeader = {
    logName: string;
    curveName: string;
    curveUnit: string;
};

export type WellborePerforation = {
    mdTop: number;
    mdBottom: number;
    tvdTop: number;
    tvdBottom: number;
    status: string;
    completionMode: string;
};

/**
 * Wellbore pick from SMDA
 *
 * Camel case attributes needed for esvIntersection component in front-end
 */
export type WellborePick = {
    northing: number;
    easting: number;
    tvd: number;
    tvdMsl: number;
    md: number;
    mdMsl: number;
    uniqueWellboreIdentifier: string;
    pickIdentifier: string;
    confidence: (string | null);
    depthReferencePoint: string;
    mdUnit: string;
};

export type WellborePicksAndStratigraphicUnits = {
    wellbore_picks: Array<WellborePick>;
    stratigraphic_units: Array<StratigraphicUnit>;
};

export type WellboreTrajectory = {
    wellboreUuid: string;
    uniqueWellboreIdentifier: string;
    tvdMslArr: Array<(number)>;
    mdArr: Array<(number)>;
    eastingArr: Array<(number)>;
    northingArr: Array<(number)>;
};

export type GetFieldsResponse = (Array<FieldInfo>);

export type GetFieldsError = unknown;

export type GetCasesData = {
    query: {
        /**
         * Field identifier
         */
        field_identifier: string;
    };
};

export type GetCasesResponse = (Array<CaseInfo>);

export type GetCasesError = (HTTPValidationError);

export type GetEnsemblesData = {
    path: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
    };
};

export type GetEnsemblesResponse = (Array<EnsembleInfo>);

export type GetEnsemblesError = (HTTPValidationError);

export type GetEnsembleDetailsData = {
    path: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetEnsembleDetailsResponse = (EnsembleDetails);

export type GetEnsembleDetailsError = (HTTPValidationError);

export type GetVectorListData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetVectorListResponse = (Array<VectorDescription>);

export type GetVectorListError = (HTTPValidationError);

export type GetRealizationsVectorDataData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Optional list of realizations to include. If not specified, all realizations will be returned.
         */
        realizations?: (Array<(number)> | null);
        /**
         * Resampling frequency. If not specified, raw data without resampling wil be returned.
         */
        resampling_frequency?: (Frequency | null);
        /**
         * Name of the vector
         */
        vector_name: string;
    };
};

export type GetRealizationsVectorDataResponse = (Array<VectorRealizationData>);

export type GetRealizationsVectorDataError = (HTTPValidationError);

export type GetTimestampsListData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency?: (Frequency | null);
    };
};

export type GetTimestampsListResponse = (Array<(number)>);

export type GetTimestampsListError = (HTTPValidationError);

export type GetHistoricalVectorDataData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Name of the non-historical vector
         */
        non_historical_vector_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency?: (Frequency | null);
    };
};

export type GetHistoricalVectorDataResponse = (VectorHistoricalData);

export type GetHistoricalVectorDataError = (HTTPValidationError);

export type GetStatisticalVectorDataData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Optional list of realizations to include. If not specified, all realizations will be included.
         */
        realizations?: (Array<(number)> | null);
        /**
         * Resampling frequency
         */
        resampling_frequency: (Frequency);
        /**
         * Optional list of statistics to calculate. If not specified, all statistics will be calculated.
         */
        statistic_functions?: (Array<StatisticFunction> | null);
        /**
         * Name of the vector
         */
        vector_name: string;
    };
};

export type GetStatisticalVectorDataResponse = (VectorStatisticData);

export type GetStatisticalVectorDataError = (HTTPValidationError);

export type GetStatisticalVectorDataPerSensitivityData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency: (Frequency);
        /**
         * Optional list of statistics to calculate. If not specified, all statistics will be calculated.
         */
        statistic_functions?: (Array<StatisticFunction> | null);
        /**
         * Name of the vector
         */
        vector_name: string;
    };
};

export type GetStatisticalVectorDataPerSensitivityResponse = (Array<VectorStatisticSensitivityData>);

export type GetStatisticalVectorDataPerSensitivityError = (HTTPValidationError);

export type GetRealizationVectorAtTimestampData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Timestamp in ms UTC to query vectors at
         */
        timestamp_utc_ms: number;
        /**
         * Name of the vector
         */
        vector_name: string;
    };
};

export type GetRealizationVectorAtTimestampResponse = (EnsembleScalarResponse);

export type GetRealizationVectorAtTimestampError = (HTTPValidationError);

export type GetTableDefinitionsData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetTableDefinitionsResponse = (Array<InplaceVolumetricsTableDefinition>);

export type GetTableDefinitionsError = (HTTPValidationError);

export type PostGetAggregatedPerRealizationTableDataData = {
    body: Body_post_get_aggregated_per_realization_table_data;
    query: {
        /**
         * Whether to accumulate fluid zones
         */
        accumulate_fluid_zones: boolean;
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * The fluid zones to aggregate by
         */
        fluid_zones: Array<FluidZone>;
        /**
         * The identifiers to group table data by
         */
        group_by_identifiers?: (Array<InplaceVolumetricsIdentifier> | null);
        /**
         * Optional list of realizations to include. If not specified, all realizations will be returned.
         */
        realizations?: (Array<(number)> | null);
        /**
         * The name of the volumetric results
         */
        result_names: Array<(string)>;
        /**
         * Table name
         */
        table_name: string;
    };
};

export type PostGetAggregatedPerRealizationTableDataResponse = (InplaceVolumetricTableDataPerFluidSelection);

export type PostGetAggregatedPerRealizationTableDataError = (HTTPValidationError);

export type PostGetAggregatedStatisticalTableDataData = {
    body: Body_post_get_aggregated_statistical_table_data;
    query: {
        /**
         * Whether to accumulate fluid zones
         */
        accumulate_fluid_zones: boolean;
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * The fluid zones to aggregate by
         */
        fluid_zones: Array<FluidZone>;
        /**
         * The identifiers to group table data by
         */
        group_by_identifiers?: (Array<InplaceVolumetricsIdentifier> | null);
        /**
         * Optional list of realizations to include. If not specified, all realizations will be returned.
         */
        realizations?: (Array<(number)> | null);
        /**
         * The name of the volumetric results
         */
        result_names: Array<(string)>;
        /**
         * Table name
         */
        table_name: string;
    };
};

export type PostGetAggregatedStatisticalTableDataResponse = (InplaceStatisticalVolumetricTableDataPerFluidSelection);

export type PostGetAggregatedStatisticalTableDataError = (HTTPValidationError);

export type GetRealizationSurfacesMetadataData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetRealizationSurfacesMetadataResponse = (SurfaceMetaSet);

export type GetRealizationSurfacesMetadataError = (HTTPValidationError);

export type GetObservedSurfacesMetadataData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
    };
};

export type GetObservedSurfacesMetadataResponse = (SurfaceMetaSet);

export type GetObservedSurfacesMetadataError = (HTTPValidationError);

export type GetSurfaceDataData = {
    query: {
        /**
         * Format of binary data in the response
         */
        data_format?: 'float' | 'png';
        /**
         * Definition of the surface onto which the data should be resampled. *SurfaceDef* object properties encoded as a `KeyValStr` string.
         */
        resample_to_def_str?: (string | null);
        /**
         * Surface address string, supported address types are *REAL*, *OBS* and *STAT*
         */
        surf_addr_str: string;
    };
};

export type GetSurfaceDataResponse = ((SurfaceDataFloat | SurfaceDataPng));

export type GetSurfaceDataError = (HTTPValidationError);

export type PostGetSurfaceIntersectionData = {
    body: Body_post_get_surface_intersection;
    query: {
        /**
         * Surface attribute
         */
        attribute: string;
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Surface name
         */
        name: string;
        /**
         * Realization number
         */
        realization_num: number;
        /**
         * Time point or time interval string
         */
        time_or_interval_str?: (string | null);
    };
};

export type PostGetSurfaceIntersectionResponse = (SurfaceIntersectionData);

export type PostGetSurfaceIntersectionError = (HTTPValidationError);

export type PostSampleSurfaceInPointsData = {
    body: Body_post_sample_surface_in_points;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization numbers
         */
        realization_nums: Array<(number)>;
        /**
         * Surface attribute
         */
        surface_attribute: string;
        /**
         * Surface name
         */
        surface_name: string;
    };
};

export type PostSampleSurfaceInPointsResponse = (Array<SurfaceRealizationSampleValues>);

export type PostSampleSurfaceInPointsError = (HTTPValidationError);

export type GetDeltaSurfaceDataData = {
    query: {
        /**
         * Format of binary data in the response
         */
        data_format?: 'float' | 'png';
        /**
         * Definition of the surface onto which the data should be resampled. *SurfaceDef* object properties encoded as a `KeyValStr` string.
         */
        resample_to_def_str?: (string | null);
        /**
         * Address string of surface A, supported types: *REAL*, *OBS* and *STAT*
         */
        surf_a_addr_str: string;
        /**
         * Address string of surface B, supported types: *REAL*, *OBS* and *STAT*
         */
        surf_b_addr_str: string;
    };
};

export type GetDeltaSurfaceDataResponse = (Array<SurfaceDataFloat>);

export type GetDeltaSurfaceDataError = (HTTPValidationError);

export type GetMisfitSurfaceDataData = {
    query: {
        /**
         * Format of binary data in the response
         */
        data_format?: 'float' | 'png';
        /**
         * Address of observed surface, only supported address type is *OBS*
         */
        obs_surf_addr_str: string;
        /**
         * Realization numbers
         */
        realizations: Array<(number)>;
        /**
         * Definition of the surface onto which the data should be resampled. *SurfaceDef* object properties encoded as a `KeyValStr` string.
         */
        resample_to_def_str?: (string | null);
        /**
         * Address of simulated surface, supported type is *PARTIAL*
         */
        sim_surf_addr_str: string;
        /**
         * Statistics to calculate
         */
        statistic_functions: Array<SurfaceStatisticFunction>;
    };
};

export type GetMisfitSurfaceDataResponse = (Array<SurfaceDataFloat>);

export type GetMisfitSurfaceDataError = (HTTPValidationError);

export type GetParameterNamesAndDescriptionData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Exclude all parameters where all values are the same value
         */
        exclude_all_values_constant?: boolean;
        /**
         * Sort order
         */
        sort_order?: 'alphabetically' | 'standard_deviation';
    };
};

export type GetParameterNamesAndDescriptionResponse = (Array<EnsembleParameterDescription>);

export type GetParameterNamesAndDescriptionError = (HTTPValidationError);

export type GetParameterData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Parameter name
         */
        parameter_name: string;
    };
};

export type GetParameterResponse = ((EnsembleParameter | null));

export type GetParameterError = (HTTPValidationError);

export type GetParametersData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetParametersResponse = (Array<EnsembleParameter>);

export type GetParametersError = (HTTPValidationError);

export type IsSensitivityRunData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type IsSensitivityRunResponse = (boolean);

export type IsSensitivityRunError = (HTTPValidationError);

export type GetSensitivitiesData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetSensitivitiesResponse = (Array<EnsembleSensitivity>);

export type GetSensitivitiesError = (HTTPValidationError);

export type GetGridModelsInfoData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization
         */
        realization_num: number;
    };
};

export type GetGridModelsInfoResponse = (Array<Grid3dInfo>);

export type GetGridModelsInfoError = (HTTPValidationError);

export type IsGridGeometrySharedData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
    };
};

export type IsGridGeometrySharedResponse = (boolean);

export type IsGridGeometrySharedError = (HTTPValidationError);

export type GridSurfaceData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
        /**
         * Max i index
         */
        i_max?: number;
        /**
         * Min i index
         */
        i_min?: number;
        /**
         * Max j index
         */
        j_max?: number;
        /**
         * Min j index
         */
        j_min?: number;
        /**
         * Max k index
         */
        k_max?: number;
        /**
         * Min k index
         */
        k_min?: number;
        /**
         * Realization
         */
        realization_num: number;
    };
};

export type GridSurfaceResponse = (Grid3dGeometry);

export type GridSurfaceError = (HTTPValidationError);

export type GridParameterData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
        /**
         * Max i index
         */
        i_max?: number;
        /**
         * Min i index
         */
        i_min?: number;
        /**
         * Max j index
         */
        j_max?: number;
        /**
         * Min j index
         */
        j_min?: number;
        /**
         * Max k index
         */
        k_max?: number;
        /**
         * Min k index
         */
        k_min?: number;
        /**
         * Grid parameter
         */
        parameter_name: string;
        /**
         * Time point or time interval string
         */
        parameter_time_or_interval_str?: (string | null);
        /**
         * Realization
         */
        realization_num: number;
    };
};

export type GridParameterResponse = (Grid3dMappedProperty);

export type GridParameterError = (HTTPValidationError);

export type PostGetPolylineIntersectionData = {
    body: Body_post_get_polyline_intersection;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
        /**
         * Grid parameter
         */
        parameter_name: string;
        /**
         * Time point or time interval string
         */
        parameter_time_or_interval_str?: (string | null);
        /**
         * Realization
         */
        realization_num: number;
    };
};

export type PostGetPolylineIntersectionResponse = (PolylineIntersection);

export type PostGetPolylineIntersectionError = (HTTPValidationError);

export type GetRealizationGroupTreeDataData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Node types
         */
        node_type_set: Array<NodeType>;
        /**
         * Realization
         */
        realization: number;
        /**
         * Resampling frequency
         */
        resampling_frequency: (Frequency);
    };
};

export type GetRealizationGroupTreeDataResponse = (GroupTreeData);

export type GetRealizationGroupTreeDataError = (HTTPValidationError);

export type TableDataData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization number
         */
        realization: number;
    };
};

export type TableDataResponse = (Array<PvtData>);

export type TableDataError = (HTTPValidationError);

export type RealizationsTablesAreEqualData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type RealizationsTablesAreEqualResponse = (boolean);

export type RealizationsTablesAreEqualError = (HTTPValidationError);

export type GetWellCompletionsDataData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Optional realizations to include. Provide single realization or list of realizations. If not specified, all realizations will be returned.
         */
        realization?: (number | Array<(number)> | null);
    };
};

export type GetWellCompletionsDataResponse = (WellCompletionsData);

export type GetWellCompletionsDataError = (HTTPValidationError);

export type GetDrilledWellboreHeadersData = {
    query: {
        /**
         * Sumo field identifier
         */
        field_identifier: string;
    };
};

export type GetDrilledWellboreHeadersResponse = (Array<WellboreHeader>);

export type GetDrilledWellboreHeadersError = (HTTPValidationError);

export type GetFieldWellTrajectoriesData = {
    query: {
        /**
         * Sumo field identifier
         */
        field_identifier: string;
        /**
         * Optional subset of well names
         */
        unique_wellbore_identifiers?: Array<(string)>;
    };
};

export type GetFieldWellTrajectoriesResponse = (Array<WellboreTrajectory>);

export type GetFieldWellTrajectoriesError = (HTTPValidationError);

export type GetWellTrajectoriesData = {
    query: {
        /**
         * Wellbore uuids
         */
        wellbore_uuids: Array<(string)>;
    };
};

export type GetWellTrajectoriesResponse = (Array<WellboreTrajectory>);

export type GetWellTrajectoriesError = (HTTPValidationError);

export type GetWellborePicksAndStratigraphicUnitsData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetWellborePicksAndStratigraphicUnitsResponse = (WellborePicksAndStratigraphicUnits);

export type GetWellborePicksAndStratigraphicUnitsError = (HTTPValidationError);

export type GetWellboreCompletionsData = {
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetWellboreCompletionsResponse = (Array<WellboreCompletion>);

export type GetWellboreCompletionsError = (HTTPValidationError);

export type GetWellboreCasingsData = {
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetWellboreCasingsResponse = (Array<WellboreCasing>);

export type GetWellboreCasingsError = (HTTPValidationError);

export type GetWellborePerforationsData = {
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetWellborePerforationsResponse = (Array<WellborePerforation>);

export type GetWellborePerforationsError = (HTTPValidationError);

export type GetWellboreLogCurveHeadersData = {
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetWellboreLogCurveHeadersResponse = (Array<WellboreLogCurveHeader>);

export type GetWellboreLogCurveHeadersError = (HTTPValidationError);

export type GetLogCurveDataData = {
    query: {
        /**
         * Log curve name
         */
        log_curve_name: string;
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
};

export type GetLogCurveDataResponse = (WellboreLogCurveData);

export type GetLogCurveDataError = (HTTPValidationError);

export type GetSeismicCubeMetaListData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetSeismicCubeMetaListResponse = (Array<SeismicCubeMeta>);

export type GetSeismicCubeMetaListError = (HTTPValidationError);

export type PostGetSeismicFenceData = {
    body: Body_post_get_seismic_fence;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Observed or simulated
         */
        observed: boolean;
        /**
         * Realization number
         */
        realization_num: number;
        /**
         * Seismic cube attribute
         */
        seismic_attribute: string;
        /**
         * Timestamp or timestep
         */
        time_or_interval_str: string;
    };
};

export type PostGetSeismicFenceResponse = (SeismicFenceData);

export type PostGetSeismicFenceError = (HTTPValidationError);

export type GetPolygonsDirectoryData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetPolygonsDirectoryResponse = (Array<PolygonsMeta>);

export type GetPolygonsDirectoryError = (HTTPValidationError);

export type GetPolygonsDataData = {
    query: {
        /**
         * Surface attribute
         */
        attribute: string;
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Surface name
         */
        name: string;
        /**
         * Realization number
         */
        realization_num: number;
    };
};

export type GetPolygonsDataResponse = (Array<PolygonData>);

export type GetPolygonsDataError = (HTTPValidationError);

export type UserInfoData = {
    query: {
        /**
         * User id
         */
        user_id: string;
    };
};

export type UserInfoResponse = (GraphUserPhoto);

export type UserInfoError = (HTTPValidationError);

export type GetObservationsData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
    };
};

export type GetObservationsResponse = (Observations);

export type GetObservationsError = (HTTPValidationError);

export type GetRftInfoData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
};

export type GetRftInfoResponse = (Array<RftInfo>);

export type GetRftInfoError = (HTTPValidationError);

export type GetRealizationDataData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realizations
         */
        realizations?: (Array<(number)> | null);
        /**
         * Response name
         */
        response_name: string;
        /**
         * Timestamps utc ms
         */
        timestamps_utc_ms?: (Array<(number)> | null);
        /**
         * Well name
         */
        well_name: string;
    };
};

export type GetRealizationDataResponse = (Array<RftRealizationData>);

export type GetRealizationDataError = (HTTPValidationError);

export type GetVfpTableNamesData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization
         */
        realization: number;
    };
};

export type GetVfpTableNamesResponse = (Array<(string)>);

export type GetVfpTableNamesError = (HTTPValidationError);

export type GetVfpTableData = {
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization
         */
        realization: number;
        /**
         * VFP table name
         */
        vfp_table_name: string;
    };
};

export type GetVfpTableResponse = ((VfpProdTable | VfpInjTable));

export type GetVfpTableError = (HTTPValidationError);

export type LoginRouteData = {
    query?: {
        redirect_url_after_login?: (string | null);
    };
};

export type LoginRouteResponse = (unknown);

export type LoginRouteError = (HTTPValidationError);

export type AuthorizedCallbackRouteResponse = (unknown);

export type AuthorizedCallbackRouteError = unknown;

export type AliveResponse = (string);

export type AliveError = unknown;

export type AliveProtectedResponse = (string);

export type AliveProtectedError = unknown;

export type LoggedInUserData = {
    query?: {
        /**
         * Set to true to include user avatar and display name from Microsoft Graph API
         */
        includeGraphApiInfo?: boolean;
    };
};

export type LoggedInUserResponse = (UserInfo);

export type LoggedInUserError = (HTTPValidationError);

export type RootResponse = (string);

export type RootError = unknown;