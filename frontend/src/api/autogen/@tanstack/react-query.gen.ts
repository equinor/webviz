// This file is auto-generated by @hey-api/openapi-ts

import {
    type Options,
    getFields,
    getCases,
    getEnsembles,
    getEnsembleDetails,
    postGetTimestampsForEnsembles,
    getVectorList,
    getDeltaEnsembleVectorList,
    getRealizationsVectorData,
    getDeltaEnsembleRealizationsVectorData,
    getTimestampsList,
    getHistoricalVectorData,
    getStatisticalVectorData,
    getDeltaEnsembleStatisticalVectorData,
    getStatisticalVectorDataPerSensitivity,
    getRealizationVectorAtTimestamp,
    getTableDefinitions,
    postGetAggregatedPerRealizationTableData,
    postGetAggregatedStatisticalTableData,
    getRealizationSurfacesMetadata,
    getObservedSurfacesMetadata,
    getSurfaceData,
    postGetSurfaceIntersection,
    postGetSampleSurfaceInPoints,
    getDeltaSurfaceData,
    getMisfitSurfaceData,
    deprecatedGetStratigraphicUnits,
    getStratigraphicUnitsForStratColumn,
    getParameterNamesAndDescription,
    getParameter,
    getParameters,
    getIsSensitivityRun,
    getSensitivities,
    getGridModelsInfo,
    getGridSurface,
    getGridParameter,
    postGetPolylineIntersection,
    getRealizationFlowNetwork,
    getTableData,
    getWellCompletionsData,
    getDrilledWellboreHeaders,
    getWellTrajectories,
    getWellborePickIdentifiers,
    getWellborePicksForPickIdentifier,
    deprecatedGetWellborePicksForWellbore,
    getWellborePicksInStratColumn,
    getWellboreStratigraphicColumns,
    getWellboreCompletions,
    getWellboreCasings,
    getWellborePerforations,
    getWellboreLogCurveHeaders,
    getLogCurveData,
    getSeismicCubeMetaList,
    getInlineSlice,
    getCrosslineSlice,
    getDepthSlice,
    postGetSeismicFence,
    getPolygonsDirectory,
    getPolygonsData,
    getUserPhoto,
    getObservations,
    getTableDefinition,
    getRealizationData,
    getVfpTableNames,
    getVfpTable,
    loginRoute,
    authorizedCallbackRoute,
    getAlive,
    getAliveProtected,
    postLogout,
    getLoggedInUser,
    root,
} from "../sdk.gen";
import { queryOptions, type UseMutationOptions, type DefaultError } from "@tanstack/react-query";
import type {
    GetFieldsData_api,
    GetCasesData_api,
    GetEnsemblesData_api,
    GetEnsembleDetailsData_api,
    PostGetTimestampsForEnsemblesData_api,
    postGetTimestampsForEnsemblesError,
    postGetTimestampsForEnsemblesResponse,
    GetVectorListData_api,
    GetDeltaEnsembleVectorListData_api,
    GetRealizationsVectorDataData_api,
    GetDeltaEnsembleRealizationsVectorDataData_api,
    GetTimestampsListData_api,
    GetHistoricalVectorDataData_api,
    GetStatisticalVectorDataData_api,
    GetDeltaEnsembleStatisticalVectorDataData_api,
    GetStatisticalVectorDataPerSensitivityData_api,
    GetRealizationVectorAtTimestampData_api,
    GetTableDefinitionsData_api,
    PostGetAggregatedPerRealizationTableDataData_api,
    postGetAggregatedPerRealizationTableDataError,
    postGetAggregatedPerRealizationTableDataResponse,
    PostGetAggregatedStatisticalTableDataData_api,
    postGetAggregatedStatisticalTableDataError,
    postGetAggregatedStatisticalTableDataResponse,
    GetRealizationSurfacesMetadataData_api,
    GetObservedSurfacesMetadataData_api,
    GetSurfaceDataData_api,
    PostGetSurfaceIntersectionData_api,
    postGetSurfaceIntersectionError,
    postGetSurfaceIntersectionResponse,
    PostGetSampleSurfaceInPointsData_api,
    postGetSampleSurfaceInPointsError,
    postGetSampleSurfaceInPointsResponse,
    GetDeltaSurfaceDataData_api,
    GetMisfitSurfaceDataData_api,
    DeprecatedGetStratigraphicUnitsData_api,
    GetStratigraphicUnitsForStratColumnData_api,
    GetParameterNamesAndDescriptionData_api,
    GetParameterData_api,
    GetParametersData_api,
    GetIsSensitivityRunData_api,
    GetSensitivitiesData_api,
    GetGridModelsInfoData_api,
    GetGridSurfaceData_api,
    GetGridParameterData_api,
    PostGetPolylineIntersectionData_api,
    postGetPolylineIntersectionError,
    postGetPolylineIntersectionResponse,
    GetRealizationFlowNetworkData_api,
    GetTableDataData_api,
    GetWellCompletionsDataData_api,
    GetDrilledWellboreHeadersData_api,
    GetWellTrajectoriesData_api,
    GetWellborePickIdentifiersData_api,
    GetWellborePicksForPickIdentifierData_api,
    DeprecatedGetWellborePicksForWellboreData_api,
    GetWellborePicksInStratColumnData_api,
    GetWellboreStratigraphicColumnsData_api,
    GetWellboreCompletionsData_api,
    GetWellboreCasingsData_api,
    GetWellborePerforationsData_api,
    GetWellboreLogCurveHeadersData_api,
    GetLogCurveDataData_api,
    GetSeismicCubeMetaListData_api,
    GetInlineSliceData_api,
    GetCrosslineSliceData_api,
    GetDepthSliceData_api,
    PostGetSeismicFenceData_api,
    postGetSeismicFenceError,
    postGetSeismicFenceResponse,
    GetPolygonsDirectoryData_api,
    GetPolygonsDataData_api,
    GetUserPhotoData_api,
    GetObservationsData_api,
    GetTableDefinitionData_api,
    GetRealizationDataData_api,
    GetVfpTableNamesData_api,
    GetVfpTableData_api,
    LoginRouteData_api,
    AuthorizedCallbackRouteData_api,
    GetAliveData_api,
    GetAliveProtectedData_api,
    PostLogoutData_api,
    postLogoutResponse,
    GetLoggedInUserData_api,
    RootData_api,
} from "../types.gen";
import type { AxiosError } from "axios";
import { client as _heyApiClient } from "../client.gen";

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, "baseURL" | "body" | "headers" | "path" | "query"> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    },
];

const createQueryKey = <TOptions extends Options>(
    id: string,
    options?: TOptions,
    infinite?: boolean,
    tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
    const params: QueryKey<TOptions>[0] = {
        _id: id,
        baseURL: options?.baseURL || (options?.client ?? _heyApiClient).getConfig().baseURL,
    } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const getFieldsQueryKey = (options?: Options<GetFieldsData_api>) => createQueryKey("getFields", options);

/**
 * Get Fields
 * Get list of fields
 */
export const getFieldsOptions = (options?: Options<GetFieldsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFields({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getFieldsQueryKey(options),
    });
};

export const getCasesQueryKey = (options: Options<GetCasesData_api>) => createQueryKey("getCases", options);

/**
 * Get Cases
 * Get list of cases for specified field
 */
export const getCasesOptions = (options: Options<GetCasesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCases({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getCasesQueryKey(options),
    });
};

export const getEnsemblesQueryKey = (options: Options<GetEnsemblesData_api>) => createQueryKey("getEnsembles", options);

/**
 * Get Ensembles
 * Get list of ensembles for a case
 */
export const getEnsemblesOptions = (options: Options<GetEnsemblesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEnsembles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getEnsemblesQueryKey(options),
    });
};

export const getEnsembleDetailsQueryKey = (options: Options<GetEnsembleDetailsData_api>) =>
    createQueryKey("getEnsembleDetails", options);

/**
 * Get Ensemble Details
 * Get more detailed information for an ensemble
 */
export const getEnsembleDetailsOptions = (options: Options<GetEnsembleDetailsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEnsembleDetails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getEnsembleDetailsQueryKey(options),
    });
};

export const postGetTimestampsForEnsemblesQueryKey = (options: Options<PostGetTimestampsForEnsemblesData_api>) =>
    createQueryKey("postGetTimestampsForEnsembles", options);

/**
 * Post Get Timestamps For Ensembles
 * Fetches ensemble timestamps for a list of ensembles
 */
export const postGetTimestampsForEnsemblesOptions = (options: Options<PostGetTimestampsForEnsemblesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetTimestampsForEnsembles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetTimestampsForEnsemblesQueryKey(options),
    });
};

/**
 * Post Get Timestamps For Ensembles
 * Fetches ensemble timestamps for a list of ensembles
 */
export const postGetTimestampsForEnsemblesMutation = (
    options?: Partial<Options<PostGetTimestampsForEnsemblesData_api>>,
): UseMutationOptions<
    postGetTimestampsForEnsemblesResponse,
    AxiosError<postGetTimestampsForEnsemblesError>,
    Options<PostGetTimestampsForEnsemblesData_api>
> => {
    const mutationOptions: UseMutationOptions<
        postGetTimestampsForEnsemblesResponse,
        AxiosError<postGetTimestampsForEnsemblesError>,
        Options<PostGetTimestampsForEnsemblesData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetTimestampsForEnsembles({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getVectorListQueryKey = (options: Options<GetVectorListData_api>) =>
    createQueryKey("getVectorList", options);

/**
 * Get Vector List
 * Get list of all vectors in a given Sumo ensemble, excluding any historical vectors
 *
 * Optionally include derived vectors.
 */
export const getVectorListOptions = (options: Options<GetVectorListData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVectorList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getVectorListQueryKey(options),
    });
};

export const getDeltaEnsembleVectorListQueryKey = (options: Options<GetDeltaEnsembleVectorListData_api>) =>
    createQueryKey("getDeltaEnsembleVectorList", options);

/**
 * Get Delta Ensemble Vector List
 * Get list of all vectors for a delta ensemble based on all vectors in a given Sumo ensemble, excluding any historical vectors
 *
 * Definition:
 *
 * delta_ensemble = comparison_ensemble - reference_ensemble
 */
export const getDeltaEnsembleVectorListOptions = (options: Options<GetDeltaEnsembleVectorListData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeltaEnsembleVectorList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDeltaEnsembleVectorListQueryKey(options),
    });
};

export const getRealizationsVectorDataQueryKey = (options: Options<GetRealizationsVectorDataData_api>) =>
    createQueryKey("getRealizationsVectorData", options);

/**
 * Get Realizations Vector Data
 * Get vector data per realization
 */
export const getRealizationsVectorDataOptions = (options: Options<GetRealizationsVectorDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRealizationsVectorData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getRealizationsVectorDataQueryKey(options),
    });
};

export const getDeltaEnsembleRealizationsVectorDataQueryKey = (
    options: Options<GetDeltaEnsembleRealizationsVectorDataData_api>,
) => createQueryKey("getDeltaEnsembleRealizationsVectorData", options);

/**
 * Get Delta Ensemble Realizations Vector Data
 * Get vector data per realization
 *
 * Definition:
 *
 * delta_ensemble = comparison_ensemble - reference_ensemble
 */
export const getDeltaEnsembleRealizationsVectorDataOptions = (
    options: Options<GetDeltaEnsembleRealizationsVectorDataData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeltaEnsembleRealizationsVectorData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDeltaEnsembleRealizationsVectorDataQueryKey(options),
    });
};

export const getTimestampsListQueryKey = (options: Options<GetTimestampsListData_api>) =>
    createQueryKey("getTimestampsList", options);

/**
 * Get Timestamps List
 * Get the intersection of available timestamps.
 * Note that when resampling_frequency is None, the pure intersection of the
 * stored raw dates will be returned. Thus the returned list of dates will not include
 * dates from long running realizations.
 * For other resampling frequencies, the date range will be expanded to cover the entire
 * time range of all the requested realizations before computing the resampled dates.
 */
export const getTimestampsListOptions = (options: Options<GetTimestampsListData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTimestampsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getTimestampsListQueryKey(options),
    });
};

export const getHistoricalVectorDataQueryKey = (options: Options<GetHistoricalVectorDataData_api>) =>
    createQueryKey("getHistoricalVectorData", options);

/**
 * Get Historical Vector Data
 */
export const getHistoricalVectorDataOptions = (options: Options<GetHistoricalVectorDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getHistoricalVectorData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getHistoricalVectorDataQueryKey(options),
    });
};

export const getStatisticalVectorDataQueryKey = (options: Options<GetStatisticalVectorDataData_api>) =>
    createQueryKey("getStatisticalVectorData", options);

/**
 * Get Statistical Vector Data
 * Get statistical vector data for an ensemble
 */
export const getStatisticalVectorDataOptions = (options: Options<GetStatisticalVectorDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStatisticalVectorData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getStatisticalVectorDataQueryKey(options),
    });
};

export const getDeltaEnsembleStatisticalVectorDataQueryKey = (
    options: Options<GetDeltaEnsembleStatisticalVectorDataData_api>,
) => createQueryKey("getDeltaEnsembleStatisticalVectorData", options);

/**
 * Get Delta Ensemble Statistical Vector Data
 * Get statistical vector data for an ensemble
 *
 * Definition:
 *
 * delta_ensemble = comparison_ensemble - reference_ensemble
 */
export const getDeltaEnsembleStatisticalVectorDataOptions = (
    options: Options<GetDeltaEnsembleStatisticalVectorDataData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeltaEnsembleStatisticalVectorData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDeltaEnsembleStatisticalVectorDataQueryKey(options),
    });
};

export const getStatisticalVectorDataPerSensitivityQueryKey = (
    options: Options<GetStatisticalVectorDataPerSensitivityData_api>,
) => createQueryKey("getStatisticalVectorDataPerSensitivity", options);

/**
 * Get Statistical Vector Data Per Sensitivity
 * Get statistical vector data for an ensemble per sensitivity
 */
export const getStatisticalVectorDataPerSensitivityOptions = (
    options: Options<GetStatisticalVectorDataPerSensitivityData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStatisticalVectorDataPerSensitivity({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getStatisticalVectorDataPerSensitivityQueryKey(options),
    });
};

export const getRealizationVectorAtTimestampQueryKey = (options: Options<GetRealizationVectorAtTimestampData_api>) =>
    createQueryKey("getRealizationVectorAtTimestamp", options);

/**
 * Get Realization Vector At Timestamp
 */
export const getRealizationVectorAtTimestampOptions = (options: Options<GetRealizationVectorAtTimestampData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRealizationVectorAtTimestamp({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getRealizationVectorAtTimestampQueryKey(options),
    });
};

export const getTableDefinitionsQueryKey = (options: Options<GetTableDefinitionsData_api>) =>
    createQueryKey("getTableDefinitions", options);

/**
 * Get Table Definitions
 * Get the inplace volumes tables definitions for a given ensemble.
 */
export const getTableDefinitionsOptions = (options: Options<GetTableDefinitionsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTableDefinitions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getTableDefinitionsQueryKey(options),
    });
};

export const postGetAggregatedPerRealizationTableDataQueryKey = (
    options: Options<PostGetAggregatedPerRealizationTableDataData_api>,
) => createQueryKey("postGetAggregatedPerRealizationTableData", options);

/**
 * Post Get Aggregated Per Realization Table Data
 * Get aggregated inplace volume data for a given table with data per realization based on requested results and categories/index filter.
 *
 * Note: This endpoint is a post endpoint because the list of indices with values can be quite large and may exceed the query string limit.
 * As the endpoint is post, the indices with values object is kept for convenience.
 */
export const postGetAggregatedPerRealizationTableDataOptions = (
    options: Options<PostGetAggregatedPerRealizationTableDataData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetAggregatedPerRealizationTableData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetAggregatedPerRealizationTableDataQueryKey(options),
    });
};

/**
 * Post Get Aggregated Per Realization Table Data
 * Get aggregated inplace volume data for a given table with data per realization based on requested results and categories/index filter.
 *
 * Note: This endpoint is a post endpoint because the list of indices with values can be quite large and may exceed the query string limit.
 * As the endpoint is post, the indices with values object is kept for convenience.
 */
export const postGetAggregatedPerRealizationTableDataMutation = (
    options?: Partial<Options<PostGetAggregatedPerRealizationTableDataData_api>>,
): UseMutationOptions<
    postGetAggregatedPerRealizationTableDataResponse,
    AxiosError<postGetAggregatedPerRealizationTableDataError>,
    Options<PostGetAggregatedPerRealizationTableDataData_api>
> => {
    const mutationOptions: UseMutationOptions<
        postGetAggregatedPerRealizationTableDataResponse,
        AxiosError<postGetAggregatedPerRealizationTableDataError>,
        Options<PostGetAggregatedPerRealizationTableDataData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetAggregatedPerRealizationTableData({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const postGetAggregatedStatisticalTableDataQueryKey = (
    options: Options<PostGetAggregatedStatisticalTableDataData_api>,
) => createQueryKey("postGetAggregatedStatisticalTableData", options);

/**
 * Post Get Aggregated Statistical Table Data
 * Get statistical inplace volumes data across selected realizations for a given table based on requested results and categories/index filter.
 *
 * Note: This endpoint is a post endpoint because the list of indices with values can be quite large and may exceed the query string limit.
 * As the endpoint is post, the indices with values object is kept for convenience.
 */
export const postGetAggregatedStatisticalTableDataOptions = (
    options: Options<PostGetAggregatedStatisticalTableDataData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetAggregatedStatisticalTableData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetAggregatedStatisticalTableDataQueryKey(options),
    });
};

/**
 * Post Get Aggregated Statistical Table Data
 * Get statistical inplace volumes data across selected realizations for a given table based on requested results and categories/index filter.
 *
 * Note: This endpoint is a post endpoint because the list of indices with values can be quite large and may exceed the query string limit.
 * As the endpoint is post, the indices with values object is kept for convenience.
 */
export const postGetAggregatedStatisticalTableDataMutation = (
    options?: Partial<Options<PostGetAggregatedStatisticalTableDataData_api>>,
): UseMutationOptions<
    postGetAggregatedStatisticalTableDataResponse,
    AxiosError<postGetAggregatedStatisticalTableDataError>,
    Options<PostGetAggregatedStatisticalTableDataData_api>
> => {
    const mutationOptions: UseMutationOptions<
        postGetAggregatedStatisticalTableDataResponse,
        AxiosError<postGetAggregatedStatisticalTableDataError>,
        Options<PostGetAggregatedStatisticalTableDataData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetAggregatedStatisticalTableData({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getRealizationSurfacesMetadataQueryKey = (options: Options<GetRealizationSurfacesMetadataData_api>) =>
    createQueryKey("getRealizationSurfacesMetadata", options);

/**
 * Get Realization Surfaces Metadata
 * Get metadata for realization surfaces in a Sumo ensemble
 */
export const getRealizationSurfacesMetadataOptions = (options: Options<GetRealizationSurfacesMetadataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRealizationSurfacesMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getRealizationSurfacesMetadataQueryKey(options),
    });
};

export const getObservedSurfacesMetadataQueryKey = (options: Options<GetObservedSurfacesMetadataData_api>) =>
    createQueryKey("getObservedSurfacesMetadata", options);

/**
 * Get Observed Surfaces Metadata
 * Get metadata for observed surfaces in a Sumo case
 */
export const getObservedSurfacesMetadataOptions = (options: Options<GetObservedSurfacesMetadataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getObservedSurfacesMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getObservedSurfacesMetadataQueryKey(options),
    });
};

export const getSurfaceDataQueryKey = (options: Options<GetSurfaceDataData_api>) =>
    createQueryKey("getSurfaceData", options);

/**
 * Get Surface Data
 * Get surface data for the specified surface.
 *
 * ---
 * *General description of the types of surface addresses that exist. The specific address types supported by this endpoint can be a subset of these.*
 *
 * - *REAL* - Realization surface address. Addresses a specific realization surface within an ensemble. Always specifies a single realization number
 * - *OBS* - Observed surface address. Addresses an observed surface which is not associated with any specific ensemble.
 * - *STAT* - Statistical surface address. Fully specifies a statistical surface, including the statistic function and which realizations to include.
 * - *PARTIAL* - Partial surface address. Similar to a realization surface address, but does not include a specific realization number.
 *
 * Structure of the different types of address strings:
 *
 * ```
 * REAL~~<case_uuid>~~<ensemble>~~<surface_name>~~<attribute>~~<realization>[~~<iso_date_or_interval>]
 * STAT~~<case_uuid>~~<ensemble>~~<surface_name>~~<attribute>~~<stat_function>~~<stat_realizations>[~~<iso_date_or_interval>]
 * OBS~~<case_uuid>~~<surface_name>~~<attribute>~~<iso_date_or_interval>
 * PARTIAL~~<case_uuid>~~<ensemble>~~<surface_name>~~<attribute>[~~<iso_date_or_interval>]
 * ```
 *
 * The `<stat_realizations>` component in a *STAT* address contains the list of realizations to include in the statistics
 * encoded as a `UintListStr` or "*" to include all realizations.
 */
export const getSurfaceDataOptions = (options: Options<GetSurfaceDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSurfaceData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSurfaceDataQueryKey(options),
    });
};

export const postGetSurfaceIntersectionQueryKey = (options: Options<PostGetSurfaceIntersectionData_api>) =>
    createQueryKey("postGetSurfaceIntersection", options);

/**
 * Post Get Surface Intersection
 * Get surface intersection data for requested surface name.
 *
 * The surface intersection data for surface name contains: An array of z-points, i.e. one z-value/depth per (x, y)-point in polyline,
 * and cumulative lengths, the accumulated length at each z-point in the array.
 */
export const postGetSurfaceIntersectionOptions = (options: Options<PostGetSurfaceIntersectionData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetSurfaceIntersection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetSurfaceIntersectionQueryKey(options),
    });
};

/**
 * Post Get Surface Intersection
 * Get surface intersection data for requested surface name.
 *
 * The surface intersection data for surface name contains: An array of z-points, i.e. one z-value/depth per (x, y)-point in polyline,
 * and cumulative lengths, the accumulated length at each z-point in the array.
 */
export const postGetSurfaceIntersectionMutation = (
    options?: Partial<Options<PostGetSurfaceIntersectionData_api>>,
): UseMutationOptions<
    postGetSurfaceIntersectionResponse,
    AxiosError<postGetSurfaceIntersectionError>,
    Options<PostGetSurfaceIntersectionData_api>
> => {
    const mutationOptions: UseMutationOptions<
        postGetSurfaceIntersectionResponse,
        AxiosError<postGetSurfaceIntersectionError>,
        Options<PostGetSurfaceIntersectionData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetSurfaceIntersection({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const postGetSampleSurfaceInPointsQueryKey = (options: Options<PostGetSampleSurfaceInPointsData_api>) =>
    createQueryKey("postGetSampleSurfaceInPoints", options);

/**
 * Post Get Sample Surface In Points
 */
export const postGetSampleSurfaceInPointsOptions = (options: Options<PostGetSampleSurfaceInPointsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetSampleSurfaceInPoints({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetSampleSurfaceInPointsQueryKey(options),
    });
};

/**
 * Post Get Sample Surface In Points
 */
export const postGetSampleSurfaceInPointsMutation = (
    options?: Partial<Options<PostGetSampleSurfaceInPointsData_api>>,
): UseMutationOptions<
    postGetSampleSurfaceInPointsResponse,
    AxiosError<postGetSampleSurfaceInPointsError>,
    Options<PostGetSampleSurfaceInPointsData_api>
> => {
    const mutationOptions: UseMutationOptions<
        postGetSampleSurfaceInPointsResponse,
        AxiosError<postGetSampleSurfaceInPointsError>,
        Options<PostGetSampleSurfaceInPointsData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetSampleSurfaceInPoints({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getDeltaSurfaceDataQueryKey = (options: Options<GetDeltaSurfaceDataData_api>) =>
    createQueryKey("getDeltaSurfaceData", options);

/**
 * Get Delta Surface Data
 */
export const getDeltaSurfaceDataOptions = (options: Options<GetDeltaSurfaceDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeltaSurfaceData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDeltaSurfaceDataQueryKey(options),
    });
};

export const getMisfitSurfaceDataQueryKey = (options: Options<GetMisfitSurfaceDataData_api>) =>
    createQueryKey("getMisfitSurfaceData", options);

/**
 * Get Misfit Surface Data
 */
export const getMisfitSurfaceDataOptions = (options: Options<GetMisfitSurfaceDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMisfitSurfaceData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getMisfitSurfaceDataQueryKey(options),
    });
};

export const deprecatedGetStratigraphicUnitsQueryKey = (options: Options<DeprecatedGetStratigraphicUnitsData_api>) =>
    createQueryKey("deprecatedGetStratigraphicUnits", options);

/**
 * Deprecated Get Stratigraphic Units
 * NOTE: This endpoint is deprecated and is to be deleted when refactoring intersection module
 */
export const deprecatedGetStratigraphicUnitsOptions = (options: Options<DeprecatedGetStratigraphicUnitsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await deprecatedGetStratigraphicUnits({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: deprecatedGetStratigraphicUnitsQueryKey(options),
    });
};

export const getStratigraphicUnitsForStratColumnQueryKey = (
    options: Options<GetStratigraphicUnitsForStratColumnData_api>,
) => createQueryKey("getStratigraphicUnitsForStratColumn", options);

/**
 * Get Stratigraphic Units For Strat Column
 */
export const getStratigraphicUnitsForStratColumnOptions = (
    options: Options<GetStratigraphicUnitsForStratColumnData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStratigraphicUnitsForStratColumn({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getStratigraphicUnitsForStratColumnQueryKey(options),
    });
};

export const getParameterNamesAndDescriptionQueryKey = (options: Options<GetParameterNamesAndDescriptionData_api>) =>
    createQueryKey("getParameterNamesAndDescription", options);

/**
 * Get Parameter Names And Description
 * Retrieve parameter names and description for an ensemble
 */
export const getParameterNamesAndDescriptionOptions = (options: Options<GetParameterNamesAndDescriptionData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getParameterNamesAndDescription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getParameterNamesAndDescriptionQueryKey(options),
    });
};

export const getParameterQueryKey = (options: Options<GetParameterData_api>) => createQueryKey("getParameter", options);

/**
 * Get Parameter
 * Get a parameter in a given Sumo ensemble
 */
export const getParameterOptions = (options: Options<GetParameterData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getParameter({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getParameterQueryKey(options),
    });
};

export const getParametersQueryKey = (options: Options<GetParametersData_api>) =>
    createQueryKey("getParameters", options);

/**
 * Get Parameters
 */
export const getParametersOptions = (options: Options<GetParametersData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getParameters({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getParametersQueryKey(options),
    });
};

export const getIsSensitivityRunQueryKey = (options: Options<GetIsSensitivityRunData_api>) =>
    createQueryKey("getIsSensitivityRun", options);

/**
 * Get Is Sensitivity Run
 * Check if a given Sumo ensemble is a sensitivity run
 */
export const getIsSensitivityRunOptions = (options: Options<GetIsSensitivityRunData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getIsSensitivityRun({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getIsSensitivityRunQueryKey(options),
    });
};

export const getSensitivitiesQueryKey = (options: Options<GetSensitivitiesData_api>) =>
    createQueryKey("getSensitivities", options);

/**
 * Get Sensitivities
 * Get sensitivities in a given Sumo ensemble
 */
export const getSensitivitiesOptions = (options: Options<GetSensitivitiesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSensitivities({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSensitivitiesQueryKey(options),
    });
};

export const getGridModelsInfoQueryKey = (options: Options<GetGridModelsInfoData_api>) =>
    createQueryKey("getGridModelsInfo", options);

/**
 * Get Grid Models Info
 * Get metadata for all 3D grid models, including bbox, dimensions and properties
 */
export const getGridModelsInfoOptions = (options: Options<GetGridModelsInfoData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGridModelsInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getGridModelsInfoQueryKey(options),
    });
};

export const getGridSurfaceQueryKey = (options: Options<GetGridSurfaceData_api>) =>
    createQueryKey("getGridSurface", options);

/**
 * Get Grid Surface
 * Get a grid
 */
export const getGridSurfaceOptions = (options: Options<GetGridSurfaceData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGridSurface({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getGridSurfaceQueryKey(options),
    });
};

export const getGridParameterQueryKey = (options: Options<GetGridParameterData_api>) =>
    createQueryKey("getGridParameter", options);

/**
 * Get Grid Parameter
 * Get a grid parameter
 */
export const getGridParameterOptions = (options: Options<GetGridParameterData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGridParameter({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getGridParameterQueryKey(options),
    });
};

export const postGetPolylineIntersectionQueryKey = (options: Options<PostGetPolylineIntersectionData_api>) =>
    createQueryKey("postGetPolylineIntersection", options);

/**
 * Post Get Polyline Intersection
 */
export const postGetPolylineIntersectionOptions = (options: Options<PostGetPolylineIntersectionData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetPolylineIntersection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetPolylineIntersectionQueryKey(options),
    });
};

/**
 * Post Get Polyline Intersection
 */
export const postGetPolylineIntersectionMutation = (
    options?: Partial<Options<PostGetPolylineIntersectionData_api>>,
): UseMutationOptions<
    postGetPolylineIntersectionResponse,
    AxiosError<postGetPolylineIntersectionError>,
    Options<PostGetPolylineIntersectionData_api>
> => {
    const mutationOptions: UseMutationOptions<
        postGetPolylineIntersectionResponse,
        AxiosError<postGetPolylineIntersectionError>,
        Options<PostGetPolylineIntersectionData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetPolylineIntersection({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getRealizationFlowNetworkQueryKey = (options: Options<GetRealizationFlowNetworkData_api>) =>
    createQueryKey("getRealizationFlowNetwork", options);

/**
 * Get Realization Flow Network
 */
export const getRealizationFlowNetworkOptions = (options: Options<GetRealizationFlowNetworkData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRealizationFlowNetwork({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getRealizationFlowNetworkQueryKey(options),
    });
};

export const getTableDataQueryKey = (options: Options<GetTableDataData_api>) => createQueryKey("getTableData", options);

/**
 * Get Table Data
 * Get pvt table data for a given Sumo ensemble and realization
 */
export const getTableDataOptions = (options: Options<GetTableDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTableData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getTableDataQueryKey(options),
    });
};

export const getWellCompletionsDataQueryKey = (options: Options<GetWellCompletionsDataData_api>) =>
    createQueryKey("getWellCompletionsData", options);

/**
 * Get Well Completions Data
 */
export const getWellCompletionsDataOptions = (options: Options<GetWellCompletionsDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellCompletionsData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellCompletionsDataQueryKey(options),
    });
};

export const getDrilledWellboreHeadersQueryKey = (options: Options<GetDrilledWellboreHeadersData_api>) =>
    createQueryKey("getDrilledWellboreHeaders", options);

/**
 * Get Drilled Wellbore Headers
 * Get wellbore headers for all wells in the field
 */
export const getDrilledWellboreHeadersOptions = (options: Options<GetDrilledWellboreHeadersData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDrilledWellboreHeaders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDrilledWellboreHeadersQueryKey(options),
    });
};

export const getWellTrajectoriesQueryKey = (options: Options<GetWellTrajectoriesData_api>) =>
    createQueryKey("getWellTrajectories", options);

/**
 * Get Well Trajectories
 * Get well trajectories for field
 */
export const getWellTrajectoriesOptions = (options: Options<GetWellTrajectoriesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellTrajectories({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellTrajectoriesQueryKey(options),
    });
};

export const getWellborePickIdentifiersQueryKey = (options: Options<GetWellborePickIdentifiersData_api>) =>
    createQueryKey("getWellborePickIdentifiers", options);

/**
 * Get Wellbore Pick Identifiers
 * Get wellbore pick identifiers for field and stratigraphic column
 */
export const getWellborePickIdentifiersOptions = (options: Options<GetWellborePickIdentifiersData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellborePickIdentifiers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellborePickIdentifiersQueryKey(options),
    });
};

export const getWellborePicksForPickIdentifierQueryKey = (
    options: Options<GetWellborePicksForPickIdentifierData_api>,
) => createQueryKey("getWellborePicksForPickIdentifier", options);

/**
 * Get Wellbore Picks For Pick Identifier
 * Get picks for wellbores for field and pick identifier
 *
 * This implies picks for multiple wellbores for given field and pick identifier.
 * E.g. picks for all wellbores in a given surface in a field.
 */
export const getWellborePicksForPickIdentifierOptions = (
    options: Options<GetWellborePicksForPickIdentifierData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellborePicksForPickIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellborePicksForPickIdentifierQueryKey(options),
    });
};

export const deprecatedGetWellborePicksForWellboreQueryKey = (
    options: Options<DeprecatedGetWellborePicksForWellboreData_api>,
) => createQueryKey("deprecatedGetWellborePicksForWellbore", options);

/**
 * Deprecated Get Wellbore Picks For Wellbore
 * Get wellbore picks for field and pick identifier
 *
 * NOTE: This endpoint is deprecated and is to be deleted when refactoring intersection module
 */
export const deprecatedGetWellborePicksForWellboreOptions = (
    options: Options<DeprecatedGetWellborePicksForWellboreData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await deprecatedGetWellborePicksForWellbore({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: deprecatedGetWellborePicksForWellboreQueryKey(options),
    });
};

export const getWellborePicksInStratColumnQueryKey = (options: Options<GetWellborePicksInStratColumnData_api>) =>
    createQueryKey("getWellborePicksInStratColumn", options);

/**
 * Get Wellbore Picks In Strat Column
 * Get wellbore picks for a single wellbore with stratigraphic column identifier
 */
export const getWellborePicksInStratColumnOptions = (options: Options<GetWellborePicksInStratColumnData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellborePicksInStratColumn({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellborePicksInStratColumnQueryKey(options),
    });
};

export const getWellboreStratigraphicColumnsQueryKey = (options: Options<GetWellboreStratigraphicColumnsData_api>) =>
    createQueryKey("getWellboreStratigraphicColumns", options);

/**
 * Get Wellbore Stratigraphic Columns
 */
export const getWellboreStratigraphicColumnsOptions = (options: Options<GetWellboreStratigraphicColumnsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellboreStratigraphicColumns({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellboreStratigraphicColumnsQueryKey(options),
    });
};

export const getWellboreCompletionsQueryKey = (options: Options<GetWellboreCompletionsData_api>) =>
    createQueryKey("getWellboreCompletions", options);

/**
 * Get Wellbore Completions
 * Get well bore completions for a single well bore
 */
export const getWellboreCompletionsOptions = (options: Options<GetWellboreCompletionsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellboreCompletions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellboreCompletionsQueryKey(options),
    });
};

export const getWellboreCasingsQueryKey = (options: Options<GetWellboreCasingsData_api>) =>
    createQueryKey("getWellboreCasings", options);

/**
 * Get Wellbore Casings
 * Get well bore casings for a single well bore
 */
export const getWellboreCasingsOptions = (options: Options<GetWellboreCasingsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellboreCasings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellboreCasingsQueryKey(options),
    });
};

export const getWellborePerforationsQueryKey = (options: Options<GetWellborePerforationsData_api>) =>
    createQueryKey("getWellborePerforations", options);

/**
 * Get Wellbore Perforations
 * Get well bore casing for a single well bore
 */
export const getWellborePerforationsOptions = (options: Options<GetWellborePerforationsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellborePerforations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellborePerforationsQueryKey(options),
    });
};

export const getWellboreLogCurveHeadersQueryKey = (options: Options<GetWellboreLogCurveHeadersData_api>) =>
    createQueryKey("getWellboreLogCurveHeaders", options);

/**
 * Get Wellbore Log Curve Headers
 * Get all log curve headers for a single well bore.
 * Logs are available from multiple sources, which can be specificed by the "sources" parameter.
 */
export const getWellboreLogCurveHeadersOptions = (options: Options<GetWellboreLogCurveHeadersData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellboreLogCurveHeaders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellboreLogCurveHeadersQueryKey(options),
    });
};

export const getLogCurveDataQueryKey = (options: Options<GetLogCurveDataData_api>) =>
    createQueryKey("getLogCurveData", options);

/**
 * Get Log Curve Data
 * Get log curve data
 */
export const getLogCurveDataOptions = (options: Options<GetLogCurveDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLogCurveData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getLogCurveDataQueryKey(options),
    });
};

export const getSeismicCubeMetaListQueryKey = (options: Options<GetSeismicCubeMetaListData_api>) =>
    createQueryKey("getSeismicCubeMetaList", options);

/**
 * Get Seismic Cube Meta List
 * Get a list of seismic cube meta.
 */
export const getSeismicCubeMetaListOptions = (options: Options<GetSeismicCubeMetaListData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSeismicCubeMetaList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSeismicCubeMetaListQueryKey(options),
    });
};

export const getInlineSliceQueryKey = (options: Options<GetInlineSliceData_api>) =>
    createQueryKey("getInlineSlice", options);

/**
 * Get Inline Slice
 * Get a seismic inline from a seismic cube.
 */
export const getInlineSliceOptions = (options: Options<GetInlineSliceData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInlineSlice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getInlineSliceQueryKey(options),
    });
};

export const getCrosslineSliceQueryKey = (options: Options<GetCrosslineSliceData_api>) =>
    createQueryKey("getCrosslineSlice", options);

/**
 * Get Crossline Slice
 * Get a seismic crossline from a seismic cube.
 */
export const getCrosslineSliceOptions = (options: Options<GetCrosslineSliceData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCrosslineSlice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getCrosslineSliceQueryKey(options),
    });
};

export const getDepthSliceQueryKey = (options: Options<GetDepthSliceData_api>) =>
    createQueryKey("getDepthSlice", options);

/**
 * Get Depth Slice
 * Get a seismic depth slice from a seismic cube.
 */
export const getDepthSliceOptions = (options: Options<GetDepthSliceData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDepthSlice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDepthSliceQueryKey(options),
    });
};

export const postGetSeismicFenceQueryKey = (options: Options<PostGetSeismicFenceData_api>) =>
    createQueryKey("postGetSeismicFence", options);

/**
 * Post Get Seismic Fence
 * Get a fence of seismic data from a polyline defined by a set of (x, y) coordinates in domain coordinate system.
 *
 * The fence data contains a set of traces perpendicular to the polyline, with one trace per (x, y)-point in polyline.
 * Each trace has equal number of samples, and is a set of sample values along the depth direction of the seismic cube.
 *
 * Returns:
 * A SeismicFenceData object with fence traces in encoded 1D array, metadata for trace array decoding and fence min/max depth.
 */
export const postGetSeismicFenceOptions = (options: Options<PostGetSeismicFenceData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetSeismicFence({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetSeismicFenceQueryKey(options),
    });
};

/**
 * Post Get Seismic Fence
 * Get a fence of seismic data from a polyline defined by a set of (x, y) coordinates in domain coordinate system.
 *
 * The fence data contains a set of traces perpendicular to the polyline, with one trace per (x, y)-point in polyline.
 * Each trace has equal number of samples, and is a set of sample values along the depth direction of the seismic cube.
 *
 * Returns:
 * A SeismicFenceData object with fence traces in encoded 1D array, metadata for trace array decoding and fence min/max depth.
 */
export const postGetSeismicFenceMutation = (
    options?: Partial<Options<PostGetSeismicFenceData_api>>,
): UseMutationOptions<
    postGetSeismicFenceResponse,
    AxiosError<postGetSeismicFenceError>,
    Options<PostGetSeismicFenceData_api>
> => {
    const mutationOptions: UseMutationOptions<
        postGetSeismicFenceResponse,
        AxiosError<postGetSeismicFenceError>,
        Options<PostGetSeismicFenceData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetSeismicFence({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getPolygonsDirectoryQueryKey = (options: Options<GetPolygonsDirectoryData_api>) =>
    createQueryKey("getPolygonsDirectory", options);

/**
 * Get Polygons Directory
 * Get a directory of polygons in a Sumo ensemble
 */
export const getPolygonsDirectoryOptions = (options: Options<GetPolygonsDirectoryData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPolygonsDirectory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getPolygonsDirectoryQueryKey(options),
    });
};

export const getPolygonsDataQueryKey = (options: Options<GetPolygonsDataData_api>) =>
    createQueryKey("getPolygonsData", options);

/**
 * Get Polygons Data
 */
export const getPolygonsDataOptions = (options: Options<GetPolygonsDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPolygonsData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getPolygonsDataQueryKey(options),
    });
};

export const getUserPhotoQueryKey = (options: Options<GetUserPhotoData_api>) => createQueryKey("getUserPhoto", options);

/**
 * Get User Photo
 * Get username, display name and avatar from Microsoft Graph API for a given user email
 */
export const getUserPhotoOptions = (options: Options<GetUserPhotoData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserPhoto({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getUserPhotoQueryKey(options),
    });
};

export const getObservationsQueryKey = (options: Options<GetObservationsData_api>) =>
    createQueryKey("getObservations", options);

/**
 * Get Observations
 * Retrieve all observations found in sumo case
 */
export const getObservationsOptions = (options: Options<GetObservationsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getObservations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getObservationsQueryKey(options),
    });
};

export const getTableDefinitionQueryKey = (options: Options<GetTableDefinitionData_api>) =>
    createQueryKey("getTableDefinition", options);

/**
 * Get Table Definition
 */
export const getTableDefinitionOptions = (options: Options<GetTableDefinitionData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTableDefinition({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getTableDefinitionQueryKey(options),
    });
};

export const getRealizationDataQueryKey = (options: Options<GetRealizationDataData_api>) =>
    createQueryKey("getRealizationData", options);

/**
 * Get Realization Data
 */
export const getRealizationDataOptions = (options: Options<GetRealizationDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRealizationData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getRealizationDataQueryKey(options),
    });
};

export const getVfpTableNamesQueryKey = (options: Options<GetVfpTableNamesData_api>) =>
    createQueryKey("getVfpTableNames", options);

/**
 * Get Vfp Table Names
 */
export const getVfpTableNamesOptions = (options: Options<GetVfpTableNamesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVfpTableNames({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getVfpTableNamesQueryKey(options),
    });
};

export const getVfpTableQueryKey = (options: Options<GetVfpTableData_api>) => createQueryKey("getVfpTable", options);

/**
 * Get Vfp Table
 */
export const getVfpTableOptions = (options: Options<GetVfpTableData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVfpTable({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getVfpTableQueryKey(options),
    });
};

export const loginRouteQueryKey = (options?: Options<LoginRouteData_api>) => createQueryKey("loginRoute", options);

/**
 *  Login Route
 */
export const loginRouteOptions = (options?: Options<LoginRouteData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await loginRoute({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: loginRouteQueryKey(options),
    });
};

export const authorizedCallbackRouteQueryKey = (options?: Options<AuthorizedCallbackRouteData_api>) =>
    createQueryKey("authorizedCallbackRoute", options);

/**
 *  Authorized Callback Route
 */
export const authorizedCallbackRouteOptions = (options?: Options<AuthorizedCallbackRouteData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authorizedCallbackRoute({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: authorizedCallbackRouteQueryKey(options),
    });
};

export const getAliveQueryKey = (options?: Options<GetAliveData_api>) => createQueryKey("getAlive", options);

/**
 * Get Alive
 */
export const getAliveOptions = (options?: Options<GetAliveData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAlive({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getAliveQueryKey(options),
    });
};

export const getAliveProtectedQueryKey = (options?: Options<GetAliveProtectedData_api>) =>
    createQueryKey("getAliveProtected", options);

/**
 * Get Alive Protected
 */
export const getAliveProtectedOptions = (options?: Options<GetAliveProtectedData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAliveProtected({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getAliveProtectedQueryKey(options),
    });
};

export const postLogoutQueryKey = (options?: Options<PostLogoutData_api>) => createQueryKey("postLogout", options);

/**
 * Post Logout
 */
export const postLogoutOptions = (options?: Options<PostLogoutData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postLogout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postLogoutQueryKey(options),
    });
};

/**
 * Post Logout
 */
export const postLogoutMutation = (
    options?: Partial<Options<PostLogoutData_api>>,
): UseMutationOptions<postLogoutResponse, AxiosError<DefaultError>, Options<PostLogoutData_api>> => {
    const mutationOptions: UseMutationOptions<
        postLogoutResponse,
        AxiosError<DefaultError>,
        Options<PostLogoutData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postLogout({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getLoggedInUserQueryKey = (options?: Options<GetLoggedInUserData_api>) =>
    createQueryKey("getLoggedInUser", options);

/**
 * Get Logged In User
 */
export const getLoggedInUserOptions = (options?: Options<GetLoggedInUserData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLoggedInUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getLoggedInUserQueryKey(options),
    });
};

export const rootQueryKey = (options?: Options<RootData_api>) => createQueryKey("root", options);

/**
 * Root
 */
export const rootOptions = (options?: Options<RootData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await root({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: rootQueryKey(options),
    });
};
