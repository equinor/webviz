// This file is auto-generated by @hey-api/openapi-ts

import {
    type DefaultError,
    type InfiniteData,
    infiniteQueryOptions,
    queryOptions,
    type UseMutationOptions,
} from "@tanstack/react-query";
import type { AxiosError } from "axios";

import { client } from "../client.gen";
import {
    authorizedCallbackRoute,
    createSession,
    createSnapshot,
    deleteSession,
    deleteSnapshot,
    deleteSnapshotAccessLog,
    deprecatedGetStratigraphicUnits,
    getAlive,
    getAliveProtected,
    getCases,
    getCrosslineSlice,
    getDeltaEnsembleRealizationsVectorData,
    getDeltaEnsembleStatisticalVectorData,
    getDeltaEnsembleVectorList,
    getDeltaSurfaceData,
    getDepthSlice,
    getDrilledWellboreHeaders,
    getEnsembleDetails,
    getFieldPerforations,
    getFields,
    getFieldScreens,
    getGridModelsInfo,
    getGridParameter,
    getGridSurface,
    getHistoricalVectorData,
    getInjectionData,
    getInlineSlice,
    getIsSensitivityRun,
    getLogCurveData,
    getLoggedInUser,
    getMisfitSurfaceData,
    getObservations,
    getObservedSurfacesMetadata,
    getParameter,
    getParameterNamesAndDescription,
    getParameters,
    getPolygonsData,
    getPolygonsDirectory,
    getProductionData,
    getRealizationData,
    getRealizationFlowNetwork,
    getRealizationSurfacesMetadata,
    getRealizationsVectorData,
    getRealizationVectorAtTimestamp,
    getSeismicCubeMetaList,
    getSeismicSlices,
    getSensitivities,
    getSession,
    getSessionMetadata,
    getSessionsMetadata,
    getSnapshot,
    getSnapshotAccessLogs,
    getSnapshotsMetadata,
    getStatisticalSurfaceDataHybrid,
    getStatisticalVectorData,
    getStatisticalVectorDataPerSensitivity,
    getStratigraphicUnitsForStratColumn,
    getSurfaceData,
    getTableData,
    getTableDefinition,
    getTableDefinitions,
    getTimestampsList,
    getUserInfo,
    getUserPhoto,
    getVectorList,
    getVfpTable,
    getVfpTableNames,
    getWellboreCasings,
    getWellboreCompletions,
    getWellboreLogCurveHeaders,
    getWellborePerforations,
    getWellborePickIdentifiers,
    getWellborePicksForPickIdentifier,
    getWellborePicksInStratColumn,
    getWellboreStratigraphicColumns,
    getWellCompletionsData,
    getWellTrajectories,
    loginRoute,
    type Options,
    postGetAggregatedPerRealizationTableData,
    postGetAggregatedStatisticalTableData,
    postGetPolylineIntersection,
    postGetSampleSurfaceInPoints,
    postGetSeismicFence,
    postGetSurfaceIntersection,
    postLogout,
    postRefreshFingerprintsForEnsembles,
    root,
    updateSession,
} from "../sdk.gen";
import type {
    AuthorizedCallbackRouteData_api,
    CreateSessionData_api,
    CreateSessionError_api,
    CreateSessionResponse_api,
    CreateSnapshotData_api,
    CreateSnapshotError_api,
    CreateSnapshotResponse_api,
    DeleteSessionData_api,
    DeleteSessionError_api,
    DeleteSnapshotAccessLogData_api,
    DeleteSnapshotAccessLogError_api,
    DeleteSnapshotData_api,
    DeleteSnapshotError_api,
    DeprecatedGetStratigraphicUnitsData_api,
    GetAliveData_api,
    GetAliveProtectedData_api,
    GetCasesData_api,
    GetCrosslineSliceData_api,
    GetDeltaEnsembleRealizationsVectorDataData_api,
    GetDeltaEnsembleStatisticalVectorDataData_api,
    GetDeltaEnsembleVectorListData_api,
    GetDeltaSurfaceDataData_api,
    GetDepthSliceData_api,
    GetDrilledWellboreHeadersData_api,
    GetEnsembleDetailsData_api,
    GetFieldPerforationsData_api,
    GetFieldScreensData_api,
    GetFieldsData_api,
    GetGridModelsInfoData_api,
    GetGridParameterData_api,
    GetGridSurfaceData_api,
    GetHistoricalVectorDataData_api,
    GetInjectionDataData_api,
    GetInlineSliceData_api,
    GetIsSensitivityRunData_api,
    GetLogCurveDataData_api,
    GetLoggedInUserData_api,
    GetMisfitSurfaceDataData_api,
    GetObservationsData_api,
    GetObservedSurfacesMetadataData_api,
    GetParameterData_api,
    GetParameterNamesAndDescriptionData_api,
    GetParametersData_api,
    GetPolygonsDataData_api,
    GetPolygonsDirectoryData_api,
    GetProductionDataData_api,
    GetRealizationDataData_api,
    GetRealizationFlowNetworkData_api,
    GetRealizationSurfacesMetadataData_api,
    GetRealizationsVectorDataData_api,
    GetRealizationVectorAtTimestampData_api,
    GetSeismicCubeMetaListData_api,
    GetSeismicSlicesData_api,
    GetSensitivitiesData_api,
    GetSessionData_api,
    GetSessionMetadataData_api,
    GetSessionsMetadataData_api,
    GetSessionsMetadataError_api,
    GetSessionsMetadataResponse_api,
    GetSnapshotAccessLogsData_api,
    GetSnapshotAccessLogsError_api,
    GetSnapshotAccessLogsResponse_api,
    GetSnapshotData_api,
    GetSnapshotsMetadataData_api,
    GetSnapshotsMetadataError_api,
    GetSnapshotsMetadataResponse_api,
    GetStatisticalSurfaceDataHybridData_api,
    GetStatisticalVectorDataData_api,
    GetStatisticalVectorDataPerSensitivityData_api,
    GetStratigraphicUnitsForStratColumnData_api,
    GetSurfaceDataData_api,
    GetTableDataData_api,
    GetTableDefinitionData_api,
    GetTableDefinitionsData_api,
    GetTimestampsListData_api,
    GetUserInfoData_api,
    GetUserPhotoData_api,
    GetVectorListData_api,
    GetVfpTableData_api,
    GetVfpTableNamesData_api,
    GetWellboreCasingsData_api,
    GetWellboreCompletionsData_api,
    GetWellboreLogCurveHeadersData_api,
    GetWellborePerforationsData_api,
    GetWellborePickIdentifiersData_api,
    GetWellborePicksForPickIdentifierData_api,
    GetWellborePicksInStratColumnData_api,
    GetWellboreStratigraphicColumnsData_api,
    GetWellCompletionsDataData_api,
    GetWellTrajectoriesData_api,
    LoginRouteData_api,
    PostGetAggregatedPerRealizationTableDataData_api,
    PostGetAggregatedPerRealizationTableDataError_api,
    PostGetAggregatedPerRealizationTableDataResponse_api,
    PostGetAggregatedStatisticalTableDataData_api,
    PostGetAggregatedStatisticalTableDataError_api,
    PostGetAggregatedStatisticalTableDataResponse_api,
    PostGetPolylineIntersectionData_api,
    PostGetPolylineIntersectionError_api,
    PostGetPolylineIntersectionResponse_api,
    PostGetSampleSurfaceInPointsData_api,
    PostGetSampleSurfaceInPointsError_api,
    PostGetSampleSurfaceInPointsResponse_api,
    PostGetSeismicFenceData_api,
    PostGetSeismicFenceError_api,
    PostGetSeismicFenceResponse_api,
    PostGetSurfaceIntersectionData_api,
    PostGetSurfaceIntersectionError_api,
    PostGetSurfaceIntersectionResponse_api,
    PostLogoutData_api,
    PostLogoutResponse_api,
    PostRefreshFingerprintsForEnsemblesData_api,
    PostRefreshFingerprintsForEnsemblesError_api,
    PostRefreshFingerprintsForEnsemblesResponse_api,
    RootData_api,
    UpdateSessionData_api,
    UpdateSessionError_api,
    UpdateSessionResponse_api,
} from "../types.gen";

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, "baseURL" | "body" | "headers" | "path" | "query"> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    },
];

const createQueryKey = <TOptions extends Options>(
    id: string,
    options?: TOptions,
    infinite?: boolean,
    tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
    const params: QueryKey<TOptions>[0] = {
        _id: id,
        baseURL: options?.baseURL || (options?.client ?? client).getConfig().baseURL,
    } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const getFieldsQueryKey = (options?: Options<GetFieldsData_api>) => createQueryKey("getFields", options);

/**
 * Get Fields
 *
 * Get list of fields
 */
export const getFieldsOptions = (options?: Options<GetFieldsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFields({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getFieldsQueryKey(options),
    });
};

export const getCasesQueryKey = (options: Options<GetCasesData_api>) => createQueryKey("getCases", options);

/**
 * Get Cases
 *
 * Get list of cases for specified field
 */
export const getCasesOptions = (options: Options<GetCasesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCases({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getCasesQueryKey(options),
    });
};

export const getEnsembleDetailsQueryKey = (options: Options<GetEnsembleDetailsData_api>) =>
    createQueryKey("getEnsembleDetails", options);

/**
 * Get Ensemble Details
 *
 * Get more detailed information for an ensemble
 */
export const getEnsembleDetailsOptions = (options: Options<GetEnsembleDetailsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEnsembleDetails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getEnsembleDetailsQueryKey(options),
    });
};

export const postRefreshFingerprintsForEnsemblesQueryKey = (
    options: Options<PostRefreshFingerprintsForEnsemblesData_api>,
) => createQueryKey("postRefreshFingerprintsForEnsembles", options);

/**
 * Post Refresh Fingerprints For Ensembles
 *
 * Retrieves freshly calculated fingerprints for a list of ensembles
 */
export const postRefreshFingerprintsForEnsemblesOptions = (
    options: Options<PostRefreshFingerprintsForEnsemblesData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postRefreshFingerprintsForEnsembles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postRefreshFingerprintsForEnsemblesQueryKey(options),
    });
};

/**
 * Post Refresh Fingerprints For Ensembles
 *
 * Retrieves freshly calculated fingerprints for a list of ensembles
 */
export const postRefreshFingerprintsForEnsemblesMutation = (
    options?: Partial<Options<PostRefreshFingerprintsForEnsemblesData_api>>,
): UseMutationOptions<
    PostRefreshFingerprintsForEnsemblesResponse_api,
    AxiosError<PostRefreshFingerprintsForEnsemblesError_api>,
    Options<PostRefreshFingerprintsForEnsemblesData_api>
> => {
    const mutationOptions: UseMutationOptions<
        PostRefreshFingerprintsForEnsemblesResponse_api,
        AxiosError<PostRefreshFingerprintsForEnsemblesError_api>,
        Options<PostRefreshFingerprintsForEnsemblesData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRefreshFingerprintsForEnsembles({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getVectorListQueryKey = (options: Options<GetVectorListData_api>) =>
    createQueryKey("getVectorList", options);

/**
 * Get Vector List
 *
 * Get list of all vectors in a given Sumo ensemble, excluding any historical vectors
 *
 * Optionally include derived vectors.
 */
export const getVectorListOptions = (options: Options<GetVectorListData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVectorList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getVectorListQueryKey(options),
    });
};

export const getDeltaEnsembleVectorListQueryKey = (options: Options<GetDeltaEnsembleVectorListData_api>) =>
    createQueryKey("getDeltaEnsembleVectorList", options);

/**
 * Get Delta Ensemble Vector List
 *
 * Get list of all vectors for a delta ensemble based on all vectors in a given Sumo ensemble, excluding any historical vectors
 *
 * Definition:
 *
 * delta_ensemble = comparison_ensemble - reference_ensemble
 */
export const getDeltaEnsembleVectorListOptions = (options: Options<GetDeltaEnsembleVectorListData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeltaEnsembleVectorList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDeltaEnsembleVectorListQueryKey(options),
    });
};

export const getRealizationsVectorDataQueryKey = (options: Options<GetRealizationsVectorDataData_api>) =>
    createQueryKey("getRealizationsVectorData", options);

/**
 * Get Realizations Vector Data
 *
 * Get vector data per realization
 */
export const getRealizationsVectorDataOptions = (options: Options<GetRealizationsVectorDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRealizationsVectorData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getRealizationsVectorDataQueryKey(options),
    });
};

export const getDeltaEnsembleRealizationsVectorDataQueryKey = (
    options: Options<GetDeltaEnsembleRealizationsVectorDataData_api>,
) => createQueryKey("getDeltaEnsembleRealizationsVectorData", options);

/**
 * Get Delta Ensemble Realizations Vector Data
 *
 * Get vector data per realization
 *
 * Definition:
 *
 * delta_ensemble = comparison_ensemble - reference_ensemble
 */
export const getDeltaEnsembleRealizationsVectorDataOptions = (
    options: Options<GetDeltaEnsembleRealizationsVectorDataData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeltaEnsembleRealizationsVectorData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDeltaEnsembleRealizationsVectorDataQueryKey(options),
    });
};

export const getTimestampsListQueryKey = (options: Options<GetTimestampsListData_api>) =>
    createQueryKey("getTimestampsList", options);

/**
 * Get Timestamps List
 *
 * Get the intersection of available timestamps.
 * Note that when resampling_frequency is None, the pure intersection of the
 * stored raw dates will be returned. Thus the returned list of dates will not include
 * dates from long running realizations.
 * For other resampling frequencies, the date range will be expanded to cover the entire
 * time range of all the requested realizations before computing the resampled dates.
 */
export const getTimestampsListOptions = (options: Options<GetTimestampsListData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTimestampsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getTimestampsListQueryKey(options),
    });
};

export const getHistoricalVectorDataQueryKey = (options: Options<GetHistoricalVectorDataData_api>) =>
    createQueryKey("getHistoricalVectorData", options);

/**
 * Get Historical Vector Data
 */
export const getHistoricalVectorDataOptions = (options: Options<GetHistoricalVectorDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getHistoricalVectorData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getHistoricalVectorDataQueryKey(options),
    });
};

export const getStatisticalVectorDataQueryKey = (options: Options<GetStatisticalVectorDataData_api>) =>
    createQueryKey("getStatisticalVectorData", options);

/**
 * Get Statistical Vector Data
 *
 * Get statistical vector data for an ensemble
 */
export const getStatisticalVectorDataOptions = (options: Options<GetStatisticalVectorDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStatisticalVectorData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getStatisticalVectorDataQueryKey(options),
    });
};

export const getDeltaEnsembleStatisticalVectorDataQueryKey = (
    options: Options<GetDeltaEnsembleStatisticalVectorDataData_api>,
) => createQueryKey("getDeltaEnsembleStatisticalVectorData", options);

/**
 * Get Delta Ensemble Statistical Vector Data
 *
 * Get statistical vector data for an ensemble
 *
 * Definition:
 *
 * delta_ensemble = comparison_ensemble - reference_ensemble
 */
export const getDeltaEnsembleStatisticalVectorDataOptions = (
    options: Options<GetDeltaEnsembleStatisticalVectorDataData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeltaEnsembleStatisticalVectorData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDeltaEnsembleStatisticalVectorDataQueryKey(options),
    });
};

export const getStatisticalVectorDataPerSensitivityQueryKey = (
    options: Options<GetStatisticalVectorDataPerSensitivityData_api>,
) => createQueryKey("getStatisticalVectorDataPerSensitivity", options);

/**
 * Get Statistical Vector Data Per Sensitivity
 *
 * Get statistical vector data for an ensemble per sensitivity
 */
export const getStatisticalVectorDataPerSensitivityOptions = (
    options: Options<GetStatisticalVectorDataPerSensitivityData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStatisticalVectorDataPerSensitivity({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getStatisticalVectorDataPerSensitivityQueryKey(options),
    });
};

export const getRealizationVectorAtTimestampQueryKey = (options: Options<GetRealizationVectorAtTimestampData_api>) =>
    createQueryKey("getRealizationVectorAtTimestamp", options);

/**
 * Get Realization Vector At Timestamp
 */
export const getRealizationVectorAtTimestampOptions = (options: Options<GetRealizationVectorAtTimestampData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRealizationVectorAtTimestamp({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getRealizationVectorAtTimestampQueryKey(options),
    });
};

export const getTableDefinitionsQueryKey = (options: Options<GetTableDefinitionsData_api>) =>
    createQueryKey("getTableDefinitions", options);

/**
 * Get Table Definitions
 *
 * Get the inplace volumes tables definitions for a given ensemble.
 */
export const getTableDefinitionsOptions = (options: Options<GetTableDefinitionsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTableDefinitions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getTableDefinitionsQueryKey(options),
    });
};

export const postGetAggregatedPerRealizationTableDataQueryKey = (
    options: Options<PostGetAggregatedPerRealizationTableDataData_api>,
) => createQueryKey("postGetAggregatedPerRealizationTableData", options);

/**
 * Post Get Aggregated Per Realization Table Data
 *
 * Get aggregated inplace volume data for a given table with data per realization based on requested results and categories/index filter.
 *
 * Note: This endpoint is a post endpoint because the list of indices with values can be quite large and may exceed the query string limit.
 * As the endpoint is post, the indices with values object is kept for convenience.
 */
export const postGetAggregatedPerRealizationTableDataOptions = (
    options: Options<PostGetAggregatedPerRealizationTableDataData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetAggregatedPerRealizationTableData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetAggregatedPerRealizationTableDataQueryKey(options),
    });
};

/**
 * Post Get Aggregated Per Realization Table Data
 *
 * Get aggregated inplace volume data for a given table with data per realization based on requested results and categories/index filter.
 *
 * Note: This endpoint is a post endpoint because the list of indices with values can be quite large and may exceed the query string limit.
 * As the endpoint is post, the indices with values object is kept for convenience.
 */
export const postGetAggregatedPerRealizationTableDataMutation = (
    options?: Partial<Options<PostGetAggregatedPerRealizationTableDataData_api>>,
): UseMutationOptions<
    PostGetAggregatedPerRealizationTableDataResponse_api,
    AxiosError<PostGetAggregatedPerRealizationTableDataError_api>,
    Options<PostGetAggregatedPerRealizationTableDataData_api>
> => {
    const mutationOptions: UseMutationOptions<
        PostGetAggregatedPerRealizationTableDataResponse_api,
        AxiosError<PostGetAggregatedPerRealizationTableDataError_api>,
        Options<PostGetAggregatedPerRealizationTableDataData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetAggregatedPerRealizationTableData({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const postGetAggregatedStatisticalTableDataQueryKey = (
    options: Options<PostGetAggregatedStatisticalTableDataData_api>,
) => createQueryKey("postGetAggregatedStatisticalTableData", options);

/**
 * Post Get Aggregated Statistical Table Data
 *
 * Get statistical inplace volumes data across selected realizations for a given table based on requested results and categories/index filter.
 *
 * Note: This endpoint is a post endpoint because the list of indices with values can be quite large and may exceed the query string limit.
 * As the endpoint is post, the indices with values object is kept for convenience.
 */
export const postGetAggregatedStatisticalTableDataOptions = (
    options: Options<PostGetAggregatedStatisticalTableDataData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetAggregatedStatisticalTableData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetAggregatedStatisticalTableDataQueryKey(options),
    });
};

/**
 * Post Get Aggregated Statistical Table Data
 *
 * Get statistical inplace volumes data across selected realizations for a given table based on requested results and categories/index filter.
 *
 * Note: This endpoint is a post endpoint because the list of indices with values can be quite large and may exceed the query string limit.
 * As the endpoint is post, the indices with values object is kept for convenience.
 */
export const postGetAggregatedStatisticalTableDataMutation = (
    options?: Partial<Options<PostGetAggregatedStatisticalTableDataData_api>>,
): UseMutationOptions<
    PostGetAggregatedStatisticalTableDataResponse_api,
    AxiosError<PostGetAggregatedStatisticalTableDataError_api>,
    Options<PostGetAggregatedStatisticalTableDataData_api>
> => {
    const mutationOptions: UseMutationOptions<
        PostGetAggregatedStatisticalTableDataResponse_api,
        AxiosError<PostGetAggregatedStatisticalTableDataError_api>,
        Options<PostGetAggregatedStatisticalTableDataData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetAggregatedStatisticalTableData({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getRealizationSurfacesMetadataQueryKey = (options: Options<GetRealizationSurfacesMetadataData_api>) =>
    createQueryKey("getRealizationSurfacesMetadata", options);

/**
 * Get Realization Surfaces Metadata
 *
 * Get metadata for realization surfaces in a Sumo ensemble
 */
export const getRealizationSurfacesMetadataOptions = (options: Options<GetRealizationSurfacesMetadataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRealizationSurfacesMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getRealizationSurfacesMetadataQueryKey(options),
    });
};

export const getObservedSurfacesMetadataQueryKey = (options: Options<GetObservedSurfacesMetadataData_api>) =>
    createQueryKey("getObservedSurfacesMetadata", options);

/**
 * Get Observed Surfaces Metadata
 *
 * Get metadata for observed surfaces in a Sumo case
 */
export const getObservedSurfacesMetadataOptions = (options: Options<GetObservedSurfacesMetadataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getObservedSurfacesMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getObservedSurfacesMetadataQueryKey(options),
    });
};

export const getSurfaceDataQueryKey = (options: Options<GetSurfaceDataData_api>) =>
    createQueryKey("getSurfaceData", options);

/**
 * Get Surface Data
 *
 * Get surface data for the specified surface.
 *
 * ---
 * *General description of the types of surface addresses that exist. The specific address types supported by this endpoint can be a subset of these.*
 *
 * - *REAL* - Realization surface address. Addresses a specific realization surface within an ensemble. Always specifies a single realization number
 * - *OBS* - Observed surface address. Addresses an observed surface which is not associated with any specific ensemble.
 * - *STAT* - Statistical surface address. Fully specifies a statistical surface, including the statistic function and which realizations to include.
 * - *PARTIAL* - Partial surface address. Similar to a realization surface address, but does not include a specific realization number.
 *
 * Structure of the different types of address strings:
 *
 * ```
 * REAL~~<case_uuid>~~<ensemble>~~<surface_name>~~<attribute>~~<realization>[~~<iso_date_or_interval>]
 * STAT~~<case_uuid>~~<ensemble>~~<surface_name>~~<attribute>~~<stat_function>~~<stat_realizations>[~~<iso_date_or_interval>]
 * OBS~~<case_uuid>~~<surface_name>~~<attribute>~~<iso_date_or_interval>
 * PARTIAL~~<case_uuid>~~<ensemble>~~<surface_name>~~<attribute>[~~<iso_date_or_interval>]
 * ```
 *
 * The `<stat_realizations>` component in a *STAT* address contains the list of realizations to include in the statistics
 * encoded as a `UintListStr` or "*" to include all realizations.
 */
export const getSurfaceDataOptions = (options: Options<GetSurfaceDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSurfaceData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSurfaceDataQueryKey(options),
    });
};

export const getStatisticalSurfaceDataHybridQueryKey = (options: Options<GetStatisticalSurfaceDataHybridData_api>) =>
    createQueryKey("getStatisticalSurfaceDataHybrid", options);

/**
 * Get Statistical Surface Data Hybrid
 */
export const getStatisticalSurfaceDataHybridOptions = (options: Options<GetStatisticalSurfaceDataHybridData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStatisticalSurfaceDataHybrid({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getStatisticalSurfaceDataHybridQueryKey(options),
    });
};

export const postGetSurfaceIntersectionQueryKey = (options: Options<PostGetSurfaceIntersectionData_api>) =>
    createQueryKey("postGetSurfaceIntersection", options);

/**
 * Post Get Surface Intersection
 *
 * Get surface intersection data for requested surface name.
 *
 * The surface intersection data for surface name contains: An array of z-points, i.e. one z-value/depth per (x, y)-point in polyline,
 * and cumulative lengths, the accumulated length at each z-point in the array.
 */
export const postGetSurfaceIntersectionOptions = (options: Options<PostGetSurfaceIntersectionData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetSurfaceIntersection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetSurfaceIntersectionQueryKey(options),
    });
};

/**
 * Post Get Surface Intersection
 *
 * Get surface intersection data for requested surface name.
 *
 * The surface intersection data for surface name contains: An array of z-points, i.e. one z-value/depth per (x, y)-point in polyline,
 * and cumulative lengths, the accumulated length at each z-point in the array.
 */
export const postGetSurfaceIntersectionMutation = (
    options?: Partial<Options<PostGetSurfaceIntersectionData_api>>,
): UseMutationOptions<
    PostGetSurfaceIntersectionResponse_api,
    AxiosError<PostGetSurfaceIntersectionError_api>,
    Options<PostGetSurfaceIntersectionData_api>
> => {
    const mutationOptions: UseMutationOptions<
        PostGetSurfaceIntersectionResponse_api,
        AxiosError<PostGetSurfaceIntersectionError_api>,
        Options<PostGetSurfaceIntersectionData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetSurfaceIntersection({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const postGetSampleSurfaceInPointsQueryKey = (options: Options<PostGetSampleSurfaceInPointsData_api>) =>
    createQueryKey("postGetSampleSurfaceInPoints", options);

/**
 * Post Get Sample Surface In Points
 */
export const postGetSampleSurfaceInPointsOptions = (options: Options<PostGetSampleSurfaceInPointsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetSampleSurfaceInPoints({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetSampleSurfaceInPointsQueryKey(options),
    });
};

/**
 * Post Get Sample Surface In Points
 */
export const postGetSampleSurfaceInPointsMutation = (
    options?: Partial<Options<PostGetSampleSurfaceInPointsData_api>>,
): UseMutationOptions<
    PostGetSampleSurfaceInPointsResponse_api,
    AxiosError<PostGetSampleSurfaceInPointsError_api>,
    Options<PostGetSampleSurfaceInPointsData_api>
> => {
    const mutationOptions: UseMutationOptions<
        PostGetSampleSurfaceInPointsResponse_api,
        AxiosError<PostGetSampleSurfaceInPointsError_api>,
        Options<PostGetSampleSurfaceInPointsData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetSampleSurfaceInPoints({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getDeltaSurfaceDataQueryKey = (options: Options<GetDeltaSurfaceDataData_api>) =>
    createQueryKey("getDeltaSurfaceData", options);

/**
 * Get Delta Surface Data
 */
export const getDeltaSurfaceDataOptions = (options: Options<GetDeltaSurfaceDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDeltaSurfaceData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDeltaSurfaceDataQueryKey(options),
    });
};

export const getMisfitSurfaceDataQueryKey = (options: Options<GetMisfitSurfaceDataData_api>) =>
    createQueryKey("getMisfitSurfaceData", options);

/**
 * Get Misfit Surface Data
 */
export const getMisfitSurfaceDataOptions = (options: Options<GetMisfitSurfaceDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMisfitSurfaceData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getMisfitSurfaceDataQueryKey(options),
    });
};

export const deprecatedGetStratigraphicUnitsQueryKey = (options: Options<DeprecatedGetStratigraphicUnitsData_api>) =>
    createQueryKey("deprecatedGetStratigraphicUnits", options);

/**
 * Deprecated Get Stratigraphic Units
 *
 * NOTE: This endpoint is deprecated and is to be deleted when refactoring intersection module
 */
export const deprecatedGetStratigraphicUnitsOptions = (options: Options<DeprecatedGetStratigraphicUnitsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await deprecatedGetStratigraphicUnits({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: deprecatedGetStratigraphicUnitsQueryKey(options),
    });
};

export const getStratigraphicUnitsForStratColumnQueryKey = (
    options: Options<GetStratigraphicUnitsForStratColumnData_api>,
) => createQueryKey("getStratigraphicUnitsForStratColumn", options);

/**
 * Get Stratigraphic Units For Strat Column
 */
export const getStratigraphicUnitsForStratColumnOptions = (
    options: Options<GetStratigraphicUnitsForStratColumnData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStratigraphicUnitsForStratColumn({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getStratigraphicUnitsForStratColumnQueryKey(options),
    });
};

export const getParameterNamesAndDescriptionQueryKey = (options: Options<GetParameterNamesAndDescriptionData_api>) =>
    createQueryKey("getParameterNamesAndDescription", options);

/**
 * Get Parameter Names And Description
 *
 * Retrieve parameter names and description for an ensemble
 */
export const getParameterNamesAndDescriptionOptions = (options: Options<GetParameterNamesAndDescriptionData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getParameterNamesAndDescription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getParameterNamesAndDescriptionQueryKey(options),
    });
};

export const getParameterQueryKey = (options: Options<GetParameterData_api>) => createQueryKey("getParameter", options);

/**
 * Get Parameter
 *
 * Get a parameter in a given Sumo ensemble
 */
export const getParameterOptions = (options: Options<GetParameterData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getParameter({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getParameterQueryKey(options),
    });
};

export const getParametersQueryKey = (options: Options<GetParametersData_api>) =>
    createQueryKey("getParameters", options);

/**
 * Get Parameters
 */
export const getParametersOptions = (options: Options<GetParametersData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getParameters({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getParametersQueryKey(options),
    });
};

export const getIsSensitivityRunQueryKey = (options: Options<GetIsSensitivityRunData_api>) =>
    createQueryKey("getIsSensitivityRun", options);

/**
 * Get Is Sensitivity Run
 *
 * Check if a given Sumo ensemble is a sensitivity run
 */
export const getIsSensitivityRunOptions = (options: Options<GetIsSensitivityRunData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getIsSensitivityRun({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getIsSensitivityRunQueryKey(options),
    });
};

export const getSensitivitiesQueryKey = (options: Options<GetSensitivitiesData_api>) =>
    createQueryKey("getSensitivities", options);

/**
 * Get Sensitivities
 *
 * Get sensitivities in a given Sumo ensemble
 */
export const getSensitivitiesOptions = (options: Options<GetSensitivitiesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSensitivities({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSensitivitiesQueryKey(options),
    });
};

export const getGridModelsInfoQueryKey = (options: Options<GetGridModelsInfoData_api>) =>
    createQueryKey("getGridModelsInfo", options);

/**
 * Get Grid Models Info
 *
 * Get metadata for all 3D grid models, including bbox, dimensions and properties
 */
export const getGridModelsInfoOptions = (options: Options<GetGridModelsInfoData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGridModelsInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getGridModelsInfoQueryKey(options),
    });
};

export const getGridSurfaceQueryKey = (options: Options<GetGridSurfaceData_api>) =>
    createQueryKey("getGridSurface", options);

/**
 * Get Grid Surface
 *
 * Get a grid
 */
export const getGridSurfaceOptions = (options: Options<GetGridSurfaceData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGridSurface({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getGridSurfaceQueryKey(options),
    });
};

export const getGridParameterQueryKey = (options: Options<GetGridParameterData_api>) =>
    createQueryKey("getGridParameter", options);

/**
 * Get Grid Parameter
 *
 * Get a grid parameter
 */
export const getGridParameterOptions = (options: Options<GetGridParameterData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGridParameter({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getGridParameterQueryKey(options),
    });
};

export const postGetPolylineIntersectionQueryKey = (options: Options<PostGetPolylineIntersectionData_api>) =>
    createQueryKey("postGetPolylineIntersection", options);

/**
 * Post Get Polyline Intersection
 */
export const postGetPolylineIntersectionOptions = (options: Options<PostGetPolylineIntersectionData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetPolylineIntersection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetPolylineIntersectionQueryKey(options),
    });
};

/**
 * Post Get Polyline Intersection
 */
export const postGetPolylineIntersectionMutation = (
    options?: Partial<Options<PostGetPolylineIntersectionData_api>>,
): UseMutationOptions<
    PostGetPolylineIntersectionResponse_api,
    AxiosError<PostGetPolylineIntersectionError_api>,
    Options<PostGetPolylineIntersectionData_api>
> => {
    const mutationOptions: UseMutationOptions<
        PostGetPolylineIntersectionResponse_api,
        AxiosError<PostGetPolylineIntersectionError_api>,
        Options<PostGetPolylineIntersectionData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetPolylineIntersection({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getRealizationFlowNetworkQueryKey = (options: Options<GetRealizationFlowNetworkData_api>) =>
    createQueryKey("getRealizationFlowNetwork", options);

/**
 * Get Realization Flow Network
 */
export const getRealizationFlowNetworkOptions = (options: Options<GetRealizationFlowNetworkData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRealizationFlowNetwork({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getRealizationFlowNetworkQueryKey(options),
    });
};

export const getProductionDataQueryKey = (options: Options<GetProductionDataData_api>) =>
    createQueryKey("getProductionData", options);

/**
 * Get Production Data
 *
 * Get allocated production per well in the time interval
 */
export const getProductionDataOptions = (options: Options<GetProductionDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProductionData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getProductionDataQueryKey(options),
    });
};

export const getInjectionDataQueryKey = (options: Options<GetInjectionDataData_api>) =>
    createQueryKey("getInjectionData", options);

/**
 * Get Injection Data
 *
 * Get allocated injection per well in the time interval
 */
export const getInjectionDataOptions = (options: Options<GetInjectionDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInjectionData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getInjectionDataQueryKey(options),
    });
};

export const getTableDataQueryKey = (options: Options<GetTableDataData_api>) => createQueryKey("getTableData", options);

/**
 * Get Table Data
 *
 * Get pvt table data for a given Sumo ensemble and realization
 */
export const getTableDataOptions = (options: Options<GetTableDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTableData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getTableDataQueryKey(options),
    });
};

export const getWellCompletionsDataQueryKey = (options: Options<GetWellCompletionsDataData_api>) =>
    createQueryKey("getWellCompletionsData", options);

/**
 * Get Well Completions Data
 */
export const getWellCompletionsDataOptions = (options: Options<GetWellCompletionsDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellCompletionsData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellCompletionsDataQueryKey(options),
    });
};

export const getDrilledWellboreHeadersQueryKey = (options: Options<GetDrilledWellboreHeadersData_api>) =>
    createQueryKey("getDrilledWellboreHeaders", options);

/**
 * Get Drilled Wellbore Headers
 *
 * Get wellbore headers for all wells in a given field
 */
export const getDrilledWellboreHeadersOptions = (options: Options<GetDrilledWellboreHeadersData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDrilledWellboreHeaders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDrilledWellboreHeadersQueryKey(options),
    });
};

export const getFieldPerforationsQueryKey = (options: Options<GetFieldPerforationsData_api>) =>
    createQueryKey("getFieldPerforations", options);

/**
 * Get Field Perforations
 *
 * Get field perforations for all wellbores in a given field.
 */
export const getFieldPerforationsOptions = (options: Options<GetFieldPerforationsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFieldPerforations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getFieldPerforationsQueryKey(options),
    });
};

export const getFieldScreensQueryKey = (options: Options<GetFieldScreensData_api>) =>
    createQueryKey("getFieldScreens", options);

/**
 * Get Field Screens
 *
 * Get field screens for all wellbores in a given field.
 * Screens are the SSDL completions with a filter on "Screen" type.
 */
export const getFieldScreensOptions = (options: Options<GetFieldScreensData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFieldScreens({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getFieldScreensQueryKey(options),
    });
};

export const getWellTrajectoriesQueryKey = (options: Options<GetWellTrajectoriesData_api>) =>
    createQueryKey("getWellTrajectories", options);

/**
 * Get Well Trajectories
 *
 * Get trajectories for wellbores in a given field. Can optionally return only a subset if a list of uuids are given
 */
export const getWellTrajectoriesOptions = (options: Options<GetWellTrajectoriesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellTrajectories({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellTrajectoriesQueryKey(options),
    });
};

export const getWellborePickIdentifiersQueryKey = (options: Options<GetWellborePickIdentifiersData_api>) =>
    createQueryKey("getWellborePickIdentifiers", options);

/**
 * Get Wellbore Pick Identifiers
 *
 * Get wellbore pick identifiers for a given stratigraphic column
 */
export const getWellborePickIdentifiersOptions = (options: Options<GetWellborePickIdentifiersData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellborePickIdentifiers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellborePickIdentifiersQueryKey(options),
    });
};

export const getWellborePicksForPickIdentifierQueryKey = (
    options: Options<GetWellborePicksForPickIdentifierData_api>,
) => createQueryKey("getWellborePicksForPickIdentifier", options);

/**
 * Get Wellbore Picks For Pick Identifier
 *
 * Get wellbore picks for a field and pick identifier
 *
 * This implies picks for multiple wellbores for given field and pick identifier.
 * E.g. picks for all wellbores in a given surface in a field.
 */
export const getWellborePicksForPickIdentifierOptions = (
    options: Options<GetWellborePicksForPickIdentifierData_api>,
) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellborePicksForPickIdentifier({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellborePicksForPickIdentifierQueryKey(options),
    });
};

export const getWellborePicksInStratColumnQueryKey = (options: Options<GetWellborePicksInStratColumnData_api>) =>
    createQueryKey("getWellborePicksInStratColumn", options);

/**
 * Get Wellbore Picks In Strat Column
 *
 * Get wellbore picks for a single wellbore within stratigraphic column
 */
export const getWellborePicksInStratColumnOptions = (options: Options<GetWellborePicksInStratColumnData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellborePicksInStratColumn({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellborePicksInStratColumnQueryKey(options),
    });
};

export const getWellboreStratigraphicColumnsQueryKey = (options: Options<GetWellboreStratigraphicColumnsData_api>) =>
    createQueryKey("getWellboreStratigraphicColumns", options);

/**
 * Get Wellbore Stratigraphic Columns
 *
 * Get stratigraphic columns for a given wellbore
 */
export const getWellboreStratigraphicColumnsOptions = (options: Options<GetWellboreStratigraphicColumnsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellboreStratigraphicColumns({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellboreStratigraphicColumnsQueryKey(options),
    });
};

export const getWellboreCompletionsQueryKey = (options: Options<GetWellboreCompletionsData_api>) =>
    createQueryKey("getWellboreCompletions", options);

/**
 * Get Wellbore Completions
 *
 * Get wellbore completions for a given wellbore
 */
export const getWellboreCompletionsOptions = (options: Options<GetWellboreCompletionsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellboreCompletions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellboreCompletionsQueryKey(options),
    });
};

export const getWellboreCasingsQueryKey = (options: Options<GetWellboreCasingsData_api>) =>
    createQueryKey("getWellboreCasings", options);

/**
 * Get Wellbore Casings
 *
 * Get wellbore casings for a given wellbore
 */
export const getWellboreCasingsOptions = (options: Options<GetWellboreCasingsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellboreCasings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellboreCasingsQueryKey(options),
    });
};

export const getWellborePerforationsQueryKey = (options: Options<GetWellborePerforationsData_api>) =>
    createQueryKey("getWellborePerforations", options);

/**
 * Get Wellbore Perforations
 *
 * Get wellbore perforations for a given wellbore
 */
export const getWellborePerforationsOptions = (options: Options<GetWellborePerforationsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellborePerforations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellborePerforationsQueryKey(options),
    });
};

export const getWellboreLogCurveHeadersQueryKey = (options: Options<GetWellboreLogCurveHeadersData_api>) =>
    createQueryKey("getWellboreLogCurveHeaders", options);

/**
 * Get Wellbore Log Curve Headers
 *
 * Get all log curve headers for a single well bore.
 * Logs are available from multiple sources, which can be specificed by the "sources" parameter.
 */
export const getWellboreLogCurveHeadersOptions = (options: Options<GetWellboreLogCurveHeadersData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWellboreLogCurveHeaders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getWellboreLogCurveHeadersQueryKey(options),
    });
};

export const getLogCurveDataQueryKey = (options: Options<GetLogCurveDataData_api>) =>
    createQueryKey("getLogCurveData", options);

/**
 * Get Log Curve Data
 *
 * Get log curve data
 */
export const getLogCurveDataOptions = (options: Options<GetLogCurveDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLogCurveData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getLogCurveDataQueryKey(options),
    });
};

export const getSeismicCubeMetaListQueryKey = (options: Options<GetSeismicCubeMetaListData_api>) =>
    createQueryKey("getSeismicCubeMetaList", options);

/**
 * Get Seismic Cube Meta List
 *
 * Get a list of seismic cube meta.
 */
export const getSeismicCubeMetaListOptions = (options: Options<GetSeismicCubeMetaListData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSeismicCubeMetaList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSeismicCubeMetaListQueryKey(options),
    });
};

export const getInlineSliceQueryKey = (options: Options<GetInlineSliceData_api>) =>
    createQueryKey("getInlineSlice", options);

/**
 * Get Inline Slice
 *
 * Get a seismic inline from a seismic cube.
 */
export const getInlineSliceOptions = (options: Options<GetInlineSliceData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInlineSlice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getInlineSliceQueryKey(options),
    });
};

export const getCrosslineSliceQueryKey = (options: Options<GetCrosslineSliceData_api>) =>
    createQueryKey("getCrosslineSlice", options);

/**
 * Get Crossline Slice
 *
 * Get a seismic crossline from a seismic cube.
 */
export const getCrosslineSliceOptions = (options: Options<GetCrosslineSliceData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCrosslineSlice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getCrosslineSliceQueryKey(options),
    });
};

export const getDepthSliceQueryKey = (options: Options<GetDepthSliceData_api>) =>
    createQueryKey("getDepthSlice", options);

/**
 * Get Depth Slice
 *
 * Get a seismic depth slice from a seismic cube.
 */
export const getDepthSliceOptions = (options: Options<GetDepthSliceData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDepthSlice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getDepthSliceQueryKey(options),
    });
};

export const getSeismicSlicesQueryKey = (options: Options<GetSeismicSlicesData_api>) =>
    createQueryKey("getSeismicSlices", options);

/**
 * Get Seismic Slices
 *
 * Get a seismic depth slice from a seismic cube.
 */
export const getSeismicSlicesOptions = (options: Options<GetSeismicSlicesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSeismicSlices({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSeismicSlicesQueryKey(options),
    });
};

export const postGetSeismicFenceQueryKey = (options: Options<PostGetSeismicFenceData_api>) =>
    createQueryKey("postGetSeismicFence", options);

/**
 * Post Get Seismic Fence
 *
 * Get a fence of seismic data from a polyline defined by a set of (x, y) coordinates in domain coordinate system.
 *
 * The fence data contains a set of traces perpendicular to the polyline, with one trace per (x, y)-point in polyline.
 * Each trace has equal number of samples, and is a set of sample values along the depth direction of the seismic cube.
 *
 * Returns:
 * A SeismicFenceData object with fence traces in encoded 1D array, metadata for trace array decoding and fence min/max depth.
 */
export const postGetSeismicFenceOptions = (options: Options<PostGetSeismicFenceData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postGetSeismicFence({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postGetSeismicFenceQueryKey(options),
    });
};

/**
 * Post Get Seismic Fence
 *
 * Get a fence of seismic data from a polyline defined by a set of (x, y) coordinates in domain coordinate system.
 *
 * The fence data contains a set of traces perpendicular to the polyline, with one trace per (x, y)-point in polyline.
 * Each trace has equal number of samples, and is a set of sample values along the depth direction of the seismic cube.
 *
 * Returns:
 * A SeismicFenceData object with fence traces in encoded 1D array, metadata for trace array decoding and fence min/max depth.
 */
export const postGetSeismicFenceMutation = (
    options?: Partial<Options<PostGetSeismicFenceData_api>>,
): UseMutationOptions<
    PostGetSeismicFenceResponse_api,
    AxiosError<PostGetSeismicFenceError_api>,
    Options<PostGetSeismicFenceData_api>
> => {
    const mutationOptions: UseMutationOptions<
        PostGetSeismicFenceResponse_api,
        AxiosError<PostGetSeismicFenceError_api>,
        Options<PostGetSeismicFenceData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGetSeismicFence({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getPolygonsDirectoryQueryKey = (options: Options<GetPolygonsDirectoryData_api>) =>
    createQueryKey("getPolygonsDirectory", options);

/**
 * Get Polygons Directory
 *
 * Get a directory of polygons in a Sumo ensemble
 */
export const getPolygonsDirectoryOptions = (options: Options<GetPolygonsDirectoryData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPolygonsDirectory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getPolygonsDirectoryQueryKey(options),
    });
};

export const getPolygonsDataQueryKey = (options: Options<GetPolygonsDataData_api>) =>
    createQueryKey("getPolygonsData", options);

/**
 * Get Polygons Data
 */
export const getPolygonsDataOptions = (options: Options<GetPolygonsDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPolygonsData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getPolygonsDataQueryKey(options),
    });
};

export const getUserInfoQueryKey = (options: Options<GetUserInfoData_api>) => createQueryKey("getUserInfo", options);

/**
 * Get User Info
 */
export const getUserInfoOptions = (options: Options<GetUserInfoData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getUserInfoQueryKey(options),
    });
};

export const getUserPhotoQueryKey = (options: Options<GetUserPhotoData_api>) => createQueryKey("getUserPhoto", options);

/**
 * Get User Photo
 *
 * Get username, display name and avatar from Microsoft Graph API for a given user email or graph identity
 */
export const getUserPhotoOptions = (options: Options<GetUserPhotoData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserPhoto({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getUserPhotoQueryKey(options),
    });
};

export const getObservationsQueryKey = (options: Options<GetObservationsData_api>) =>
    createQueryKey("getObservations", options);

/**
 * Get Observations
 *
 * Retrieve all observations found in sumo case
 */
export const getObservationsOptions = (options: Options<GetObservationsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getObservations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getObservationsQueryKey(options),
    });
};

export const getTableDefinitionQueryKey = (options: Options<GetTableDefinitionData_api>) =>
    createQueryKey("getTableDefinition", options);

/**
 * Get Table Definition
 */
export const getTableDefinitionOptions = (options: Options<GetTableDefinitionData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTableDefinition({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getTableDefinitionQueryKey(options),
    });
};

export const getRealizationDataQueryKey = (options: Options<GetRealizationDataData_api>) =>
    createQueryKey("getRealizationData", options);

/**
 * Get Realization Data
 */
export const getRealizationDataOptions = (options: Options<GetRealizationDataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRealizationData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getRealizationDataQueryKey(options),
    });
};

export const getVfpTableNamesQueryKey = (options: Options<GetVfpTableNamesData_api>) =>
    createQueryKey("getVfpTableNames", options);

/**
 * Get Vfp Table Names
 */
export const getVfpTableNamesOptions = (options: Options<GetVfpTableNamesData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVfpTableNames({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getVfpTableNamesQueryKey(options),
    });
};

export const getVfpTableQueryKey = (options: Options<GetVfpTableData_api>) => createQueryKey("getVfpTable", options);

/**
 * Get Vfp Table
 */
export const getVfpTableOptions = (options: Options<GetVfpTableData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVfpTable({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getVfpTableQueryKey(options),
    });
};

export const getSessionsMetadataQueryKey = (options?: Options<GetSessionsMetadataData_api>) =>
    createQueryKey("getSessionsMetadata", options);

/**
 * Get Sessions Metadata
 *
 * Get a paginated list of session metadata for the authenticated user.
 *
 * This endpoint returns session metadata (without content) with support for:
 * - **Pagination**: Use the continuation token to fetch subsequent pages
 * - **Sorting**: Sort by various fields in ascending or descending order
 * - **Case-insensitive sorting**: Optional lowercase sorting for text fields
 * - **Filtering**: Filter by title and date ranges
 *
 * The response includes a continuation token for fetching the next page of results.
 */
export const getSessionsMetadataOptions = (options?: Options<GetSessionsMetadataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionsMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSessionsMetadataQueryKey(options),
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">>(
    queryKey: QueryKey<Options>,
    page: K,
) => {
    const params = {
        ...queryKey[0],
    };
    if (page.body) {
        params.body = {
            ...(queryKey[0].body as any),
            ...(page.body as any),
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers,
        };
    }
    if (page.path) {
        params.path = {
            ...(queryKey[0].path as any),
            ...(page.path as any),
        };
    }
    if (page.query) {
        params.query = {
            ...(queryKey[0].query as any),
            ...(page.query as any),
        };
    }
    return params as unknown as typeof page;
};

export const getSessionsMetadataInfiniteQueryKey = (
    options?: Options<GetSessionsMetadataData_api>,
): QueryKey<Options<GetSessionsMetadataData_api>> => createQueryKey("getSessionsMetadata", options, true);

/**
 * Get Sessions Metadata
 *
 * Get a paginated list of session metadata for the authenticated user.
 *
 * This endpoint returns session metadata (without content) with support for:
 * - **Pagination**: Use the continuation token to fetch subsequent pages
 * - **Sorting**: Sort by various fields in ascending or descending order
 * - **Case-insensitive sorting**: Optional lowercase sorting for text fields
 * - **Filtering**: Filter by title and date ranges
 *
 * The response includes a continuation token for fetching the next page of results.
 */
export const getSessionsMetadataInfiniteOptions = (options?: Options<GetSessionsMetadataData_api>) => {
    return infiniteQueryOptions<
        GetSessionsMetadataResponse_api,
        AxiosError<GetSessionsMetadataError_api>,
        InfiniteData<GetSessionsMetadataResponse_api>,
        QueryKey<Options<GetSessionsMetadataData_api>>,
        string | null | Pick<QueryKey<Options<GetSessionsMetadataData_api>>[0], "body" | "headers" | "path" | "query">
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GetSessionsMetadataData_api>>[0],
                    "body" | "headers" | "path" | "query"
                > =
                    typeof pageParam === "object"
                        ? pageParam
                        : {
                              query: {
                                  cursor: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await getSessionsMetadata({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: getSessionsMetadataInfiniteQueryKey(options),
        },
    );
};

export const createSessionQueryKey = (options: Options<CreateSessionData_api>) =>
    createQueryKey("createSession", options);

/**
 * Create Session
 *
 * Create a new session for the authenticated user.
 *
 * Provide:
 * - **title**: Session title (required)
 * - **description**: Optional description
 * - **content**: Session content (required)
 *
 * The system automatically generates:
 * - Unique session ID
 * - Creation and update timestamps
 * - Version number (starts at 1)
 * - Content hash for integrity checking
 *
 * Returns the ID of the newly created session.
 */
export const createSessionOptions = (options: Options<CreateSessionData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSession({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: createSessionQueryKey(options),
    });
};

/**
 * Create Session
 *
 * Create a new session for the authenticated user.
 *
 * Provide:
 * - **title**: Session title (required)
 * - **description**: Optional description
 * - **content**: Session content (required)
 *
 * The system automatically generates:
 * - Unique session ID
 * - Creation and update timestamps
 * - Version number (starts at 1)
 * - Content hash for integrity checking
 *
 * Returns the ID of the newly created session.
 */
export const createSessionMutation = (
    options?: Partial<Options<CreateSessionData_api>>,
): UseMutationOptions<
    CreateSessionResponse_api,
    AxiosError<CreateSessionError_api>,
    Options<CreateSessionData_api>
> => {
    const mutationOptions: UseMutationOptions<
        CreateSessionResponse_api,
        AxiosError<CreateSessionError_api>,
        Options<CreateSessionData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await createSession({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

/**
 * Delete Session
 *
 * Permanently delete a session.
 *
 * This operation:
 * - Removes the session document from the database
 * - Cannot be undone
 * - Requires ownership verification
 *
 * Only the session owner can delete their sessions.
 */
export const deleteSessionMutation = (
    options?: Partial<Options<DeleteSessionData_api>>,
): UseMutationOptions<unknown, AxiosError<DeleteSessionError_api>, Options<DeleteSessionData_api>> => {
    const mutationOptions: UseMutationOptions<
        unknown,
        AxiosError<DeleteSessionError_api>,
        Options<DeleteSessionData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSession({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getSessionQueryKey = (options: Options<GetSessionData_api>) => createQueryKey("getSession", options);

/**
 * Get Session
 *
 * Retrieve a complete session by its ID.
 *
 * Returns the full session document including:
 * - Session metadata (title, description, timestamps, version, etc.)
 * - Complete session content
 *
 * Only the session owner can access this endpoint.
 */
export const getSessionOptions = (options: Options<GetSessionData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSession({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSessionQueryKey(options),
    });
};

/**
 * Update Session
 *
 * Update an existing session with partial or complete changes.
 *
 * You can update any combination of:
 * - **title**: New session title
 * - **description**: New description
 * - **content**: New session content
 *
 * All fields are optional - only provided fields will be updated.
 *
 * The system automatically:
 * - Updates the `updated_at` timestamp
 * - Increments the version number
 * - Recalculates the content hash if content changed
 * - Preserves ownership and creation metadata
 *
 * Returns the complete updated session.
 *
 * Only the session owner can update their sessions.
 */
export const updateSessionMutation = (
    options?: Partial<Options<UpdateSessionData_api>>,
): UseMutationOptions<
    UpdateSessionResponse_api,
    AxiosError<UpdateSessionError_api>,
    Options<UpdateSessionData_api>
> => {
    const mutationOptions: UseMutationOptions<
        UpdateSessionResponse_api,
        AxiosError<UpdateSessionError_api>,
        Options<UpdateSessionData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateSession({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getSessionMetadataQueryKey = (options: Options<GetSessionMetadataData_api>) =>
    createQueryKey("getSessionMetadata", options);

/**
 * Get Session Metadata
 *
 * Retrieve only the metadata for a specific session.
 *
 * Returns session metadata without the content, useful for:
 * - Listing sessions with details
 * - Checking version or timestamps
 * - Lightweight operations that don't need full content
 *
 * Only the session owner can access this endpoint.
 */
export const getSessionMetadataOptions = (options: Options<GetSessionMetadataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSessionMetadataQueryKey(options),
    });
};

export const getSnapshotAccessLogsQueryKey = (options?: Options<GetSnapshotAccessLogsData_api>) =>
    createQueryKey("getSnapshotAccessLogs", options);

/**
 * Get Snapshot Access Logs
 *
 * Get a list of all snapshots you have visited.
 *
 * This endpoint tracks your interaction history with snapshots, including:
 * - Snapshots you've created (counted as implicit visits)
 * - Snapshots you've viewed
 * - Snapshots shared with you that you've accessed
 *
 * Each access log entry includes:
 * - **Visit count**: Number of times you've viewed the snapshot
 * - **First visited**: Timestamp of your first visit
 * - **Last visited**: Timestamp of your most recent visit
 * - **Snapshot metadata**: Title, description, creation date
 * - **Deletion status**: Whether the snapshot has been deleted
 *
 * Supports pagination, sorting, and filtering by:
 * - Title (case insensitive)
 * - Creation date range
 * - Last visited date range
 */
export const getSnapshotAccessLogsOptions = (options?: Options<GetSnapshotAccessLogsData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSnapshotAccessLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSnapshotAccessLogsQueryKey(options),
    });
};

export const getSnapshotAccessLogsInfiniteQueryKey = (
    options?: Options<GetSnapshotAccessLogsData_api>,
): QueryKey<Options<GetSnapshotAccessLogsData_api>> => createQueryKey("getSnapshotAccessLogs", options, true);

/**
 * Get Snapshot Access Logs
 *
 * Get a list of all snapshots you have visited.
 *
 * This endpoint tracks your interaction history with snapshots, including:
 * - Snapshots you've created (counted as implicit visits)
 * - Snapshots you've viewed
 * - Snapshots shared with you that you've accessed
 *
 * Each access log entry includes:
 * - **Visit count**: Number of times you've viewed the snapshot
 * - **First visited**: Timestamp of your first visit
 * - **Last visited**: Timestamp of your most recent visit
 * - **Snapshot metadata**: Title, description, creation date
 * - **Deletion status**: Whether the snapshot has been deleted
 *
 * Supports pagination, sorting, and filtering by:
 * - Title (case insensitive)
 * - Creation date range
 * - Last visited date range
 */
export const getSnapshotAccessLogsInfiniteOptions = (options?: Options<GetSnapshotAccessLogsData_api>) => {
    return infiniteQueryOptions<
        GetSnapshotAccessLogsResponse_api,
        AxiosError<GetSnapshotAccessLogsError_api>,
        InfiniteData<GetSnapshotAccessLogsResponse_api>,
        QueryKey<Options<GetSnapshotAccessLogsData_api>>,
        string | null | Pick<QueryKey<Options<GetSnapshotAccessLogsData_api>>[0], "body" | "headers" | "path" | "query">
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GetSnapshotAccessLogsData_api>>[0],
                    "body" | "headers" | "path" | "query"
                > =
                    typeof pageParam === "object"
                        ? pageParam
                        : {
                              query: {
                                  cursor: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await getSnapshotAccessLogs({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: getSnapshotAccessLogsInfiniteQueryKey(options),
        },
    );
};

export const getSnapshotsMetadataQueryKey = (options?: Options<GetSnapshotsMetadataData_api>) =>
    createQueryKey("getSnapshotsMetadata", options);

/**
 * Get Snapshots Metadata
 *
 * Get a paginated list of your snapshot metadata.
 *
 * Returns metadata for snapshots you own (without content) with support for:
 * - **Pagination**: Use continuation tokens for large result sets
 * - **Sorting**: Sort by title, creation date, etc.
 * - **Filtering**: Filter by title and date ranges
 *
 * Snapshots are immutable records that can be shared with others.
 * They are separate from sessions and are intended for point-in-time captures.
 *
 * Note: Consider using `/persistence/snapshot_access_logs` to see both your snapshots and ones shared with you.
 */
export const getSnapshotsMetadataOptions = (options?: Options<GetSnapshotsMetadataData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSnapshotsMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSnapshotsMetadataQueryKey(options),
    });
};

export const getSnapshotsMetadataInfiniteQueryKey = (
    options?: Options<GetSnapshotsMetadataData_api>,
): QueryKey<Options<GetSnapshotsMetadataData_api>> => createQueryKey("getSnapshotsMetadata", options, true);

/**
 * Get Snapshots Metadata
 *
 * Get a paginated list of your snapshot metadata.
 *
 * Returns metadata for snapshots you own (without content) with support for:
 * - **Pagination**: Use continuation tokens for large result sets
 * - **Sorting**: Sort by title, creation date, etc.
 * - **Filtering**: Filter by title and date ranges
 *
 * Snapshots are immutable records that can be shared with others.
 * They are separate from sessions and are intended for point-in-time captures.
 *
 * Note: Consider using `/persistence/snapshot_access_logs` to see both your snapshots and ones shared with you.
 */
export const getSnapshotsMetadataInfiniteOptions = (options?: Options<GetSnapshotsMetadataData_api>) => {
    return infiniteQueryOptions<
        GetSnapshotsMetadataResponse_api,
        AxiosError<GetSnapshotsMetadataError_api>,
        InfiniteData<GetSnapshotsMetadataResponse_api>,
        QueryKey<Options<GetSnapshotsMetadataData_api>>,
        string | null | Pick<QueryKey<Options<GetSnapshotsMetadataData_api>>[0], "body" | "headers" | "path" | "query">
    >(
        // @ts-ignore
        {
            queryFn: async ({ pageParam, queryKey, signal }) => {
                // @ts-ignore
                const page: Pick<
                    QueryKey<Options<GetSnapshotsMetadataData_api>>[0],
                    "body" | "headers" | "path" | "query"
                > =
                    typeof pageParam === "object"
                        ? pageParam
                        : {
                              query: {
                                  cursor: pageParam,
                              },
                          };
                const params = createInfiniteParams(queryKey, page);
                const { data } = await getSnapshotsMetadata({
                    ...options,
                    ...params,
                    signal,
                    throwOnError: true,
                });
                return data;
            },
            queryKey: getSnapshotsMetadataInfiniteQueryKey(options),
        },
    );
};

export const createSnapshotQueryKey = (options: Options<CreateSnapshotData_api>) =>
    createQueryKey("createSnapshot", options);

/**
 * Create Snapshot
 *
 * Create a new snapshot for point-in-time capture.
 *
 * Provide:
 * - **title**: Snapshot title (required)
 * - **description**: Optional description
 * - **content**: Snapshot content (required)
 *
 * The system automatically:
 * - Generates a unique snapshot ID
 * - Records creation timestamp
 * - Calculates content hash for integrity
 * - **Logs an implicit visit** (so it appears in your visited snapshots)
 *
 * Snapshots are immutable and can be shared with others via their ID.
 *
 * Returns the ID of the newly created snapshot.
 */
export const createSnapshotOptions = (options: Options<CreateSnapshotData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSnapshot({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: createSnapshotQueryKey(options),
    });
};

/**
 * Create Snapshot
 *
 * Create a new snapshot for point-in-time capture.
 *
 * Provide:
 * - **title**: Snapshot title (required)
 * - **description**: Optional description
 * - **content**: Snapshot content (required)
 *
 * The system automatically:
 * - Generates a unique snapshot ID
 * - Records creation timestamp
 * - Calculates content hash for integrity
 * - **Logs an implicit visit** (so it appears in your visited snapshots)
 *
 * Snapshots are immutable and can be shared with others via their ID.
 *
 * Returns the ID of the newly created snapshot.
 */
export const createSnapshotMutation = (
    options?: Partial<Options<CreateSnapshotData_api>>,
): UseMutationOptions<
    CreateSnapshotResponse_api,
    AxiosError<CreateSnapshotError_api>,
    Options<CreateSnapshotData_api>
> => {
    const mutationOptions: UseMutationOptions<
        CreateSnapshotResponse_api,
        AxiosError<CreateSnapshotError_api>,
        Options<CreateSnapshotData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await createSnapshot({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

/**
 * Delete Snapshot
 *
 * Permanently delete a snapshot.
 *
 * This operation:
 * - Removes the snapshot document from the database
 * - Marks all access logs as deleted (background task)
 * - Cannot be undone
 * - Requires ownership verification
 *
 * **Background Processing:**
 * Access logs are marked as deleted asynchronously to avoid blocking the response.
 * This typically completes within seconds for snapshots with <150 visitor logs.
 *
 * Only the snapshot owner can delete their snapshots.
 */
export const deleteSnapshotMutation = (
    options?: Partial<Options<DeleteSnapshotData_api>>,
): UseMutationOptions<unknown, AxiosError<DeleteSnapshotError_api>, Options<DeleteSnapshotData_api>> => {
    const mutationOptions: UseMutationOptions<
        unknown,
        AxiosError<DeleteSnapshotError_api>,
        Options<DeleteSnapshotData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSnapshot({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getSnapshotQueryKey = (options: Options<GetSnapshotData_api>) => createQueryKey("getSnapshot", options);

/**
 * Get Snapshot
 *
 * Retrieve a complete snapshot by its ID.
 *
 * Returns the full snapshot document including:
 * - Snapshot metadata (title, description, creation date, etc.)
 * - Complete snapshot content
 *
 * **Important**: This endpoint automatically tracks your visit:
 * - Increments the visit counter
 * - Updates the "last visited" timestamp
 * - Creates an access log entry if this is your first visit
 *
 * This allows you to see your viewing history in `/persistence/snapshot_access_logs`.
 *
 * Any user with the snapshot ID can access snapshots (they are shareable).
 */
export const getSnapshotOptions = (options: Options<GetSnapshotData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSnapshot({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getSnapshotQueryKey(options),
    });
};

/**
 * Delete Snapshot Access Log
 *
 * Delete your access log for a specific snapshot.
 *
 * This operation:
 * - Removes your access log entry for the given snapshot
 * - Does NOT affect the snapshot itself or other users' logs
 *
 * Use this endpoint to clear your visit history for a snapshot
 * without deleting the snapshot or impacting other users.
 */
export const deleteSnapshotAccessLogMutation = (
    options?: Partial<Options<DeleteSnapshotAccessLogData_api>>,
): UseMutationOptions<
    unknown,
    AxiosError<DeleteSnapshotAccessLogError_api>,
    Options<DeleteSnapshotAccessLogData_api>
> => {
    const mutationOptions: UseMutationOptions<
        unknown,
        AxiosError<DeleteSnapshotAccessLogError_api>,
        Options<DeleteSnapshotAccessLogData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSnapshotAccessLog({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const loginRouteQueryKey = (options?: Options<LoginRouteData_api>) => createQueryKey("loginRoute", options);

/**
 *  Login Route
 */
export const loginRouteOptions = (options?: Options<LoginRouteData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await loginRoute({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: loginRouteQueryKey(options),
    });
};

export const authorizedCallbackRouteQueryKey = (options?: Options<AuthorizedCallbackRouteData_api>) =>
    createQueryKey("authorizedCallbackRoute", options);

/**
 *  Authorized Callback Route
 */
export const authorizedCallbackRouteOptions = (options?: Options<AuthorizedCallbackRouteData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authorizedCallbackRoute({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: authorizedCallbackRouteQueryKey(options),
    });
};

export const getAliveQueryKey = (options?: Options<GetAliveData_api>) => createQueryKey("getAlive", options);

/**
 * Get Alive
 */
export const getAliveOptions = (options?: Options<GetAliveData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAlive({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getAliveQueryKey(options),
    });
};

export const getAliveProtectedQueryKey = (options?: Options<GetAliveProtectedData_api>) =>
    createQueryKey("getAliveProtected", options);

/**
 * Get Alive Protected
 */
export const getAliveProtectedOptions = (options?: Options<GetAliveProtectedData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAliveProtected({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getAliveProtectedQueryKey(options),
    });
};

export const postLogoutQueryKey = (options?: Options<PostLogoutData_api>) => createQueryKey("postLogout", options);

/**
 * Post Logout
 */
export const postLogoutOptions = (options?: Options<PostLogoutData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postLogout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: postLogoutQueryKey(options),
    });
};

/**
 * Post Logout
 */
export const postLogoutMutation = (
    options?: Partial<Options<PostLogoutData_api>>,
): UseMutationOptions<PostLogoutResponse_api, AxiosError<DefaultError>, Options<PostLogoutData_api>> => {
    const mutationOptions: UseMutationOptions<
        PostLogoutResponse_api,
        AxiosError<DefaultError>,
        Options<PostLogoutData_api>
    > = {
        mutationFn: async (fnOptions) => {
            const { data } = await postLogout({
                ...options,
                ...fnOptions,
                throwOnError: true,
            });
            return data;
        },
    };
    return mutationOptions;
};

export const getLoggedInUserQueryKey = (options?: Options<GetLoggedInUserData_api>) =>
    createQueryKey("getLoggedInUser", options);

/**
 * Get Logged In User
 */
export const getLoggedInUserOptions = (options?: Options<GetLoggedInUserData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLoggedInUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: getLoggedInUserQueryKey(options),
    });
};

export const rootQueryKey = (options?: Options<RootData_api>) => createQueryKey("root", options);

/**
 * Root
 */
export const rootOptions = (options?: Options<RootData_api>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await root({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true,
            });
            return data;
        },
        queryKey: rootQueryKey(options),
    });
};
