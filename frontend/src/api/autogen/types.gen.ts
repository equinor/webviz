// This file is auto-generated by @hey-api/openapi-ts

export enum Alq {
    GRAT = "GRAT",
    IGLR = "IGLR",
    TGLR = "TGLR",
    PUMP = "PUMP",
    COMP = "COMP",
    DENO = "DENO",
    DENG = "DENG",
    BEAN = "BEAN",
    "''" = "''",
}

export type B64FloatArray = {
    element_type: "float32" | "float64";
    data_b64str: string;
};

export type B64UintArray = {
    element_type: "uint8" | "uint16" | "uint32" | "uint64";
    data_b64str: string;
};

export type BodyPostGetAggregatedPerRealizationTableData = {
    /**
     * Selected identifiers and wanted values
     */
    identifiers_with_values: Array<InplaceVolumetricsIdentifierWithValues>;
};

export type BodyPostGetAggregatedStatisticalTableData = {
    /**
     * Selected identifiers and wanted values
     */
    identifiers_with_values: Array<InplaceVolumetricsIdentifierWithValues>;
};

export type BodyPostGetPolylineIntersection = {
    polyline_utm_xy: Array<number>;
};

export type BodyPostGetSampleSurfaceInPoints = {
    sample_points: PointSetXy;
};

export type BodyPostGetSeismicFence = {
    polyline: SeismicFencePolyline;
};

export type BodyPostGetSurfaceIntersection = {
    cumulative_length_polyline: SurfaceIntersectionCumulativeLengthPolyline;
};

export type BoundingBox2D = {
    min_x: number;
    min_y: number;
    max_x: number;
    max_y: number;
};

/**
 * Bounding box for a 3D grid geometry
 */
export type BoundingBox3D = {
    xmin: number;
    ymin: number;
    zmin: number;
    xmax: number;
    ymax: number;
    zmax: number;
};

export type CaseInfo = {
    uuid: string;
    name: string;
    status: string;
    user: string;
};

export type Completions = {
    sortedCompletionDateIndices: Array<number>;
    open: Array<number>;
    shut: Array<number>;
    khMean: Array<number>;
    khMin: Array<number>;
    khMax: Array<number>;
};

export type DatedFlowNetwork = {
    dates: Array<string>;
    network: NetworkNode;
};

export type DerivedVectorInfo = {
    type: DerivedVectorType;
    sourceVector: string;
};

export enum DerivedVectorType {
    PER_DAY = "PER_DAY",
    PER_INTVL = "PER_INTVL",
}

/**
 * Holds information that describes how a discrete curve value should be presented to the user.
 */
export type DiscreteValueMetadata = {
    code: number;
    identifier: string;
    rgbColor: [number, number, number];
};

export type EnsembleDetails = {
    name: string;
    field_identifier: string;
    case_name: string;
    case_uuid: string;
    realizations: Array<number>;
    stratigraphic_column_identifier: string;
};

export type EnsembleInfo = {
    name: string;
    realization_count: number;
};

/**
 * Description/data for a single parameter in an ensemble
 */
export type EnsembleParameter = {
    name: string;
    is_logarithmic: boolean;
    is_discrete: boolean;
    is_constant: boolean;
    group_name: string | null;
    descriptive_name: string | null;
    realizations: Array<number>;
    values: Array<number> | Array<number> | Array<string>;
};

export type EnsembleParameterDescription = {
    name: string;
    group_name: string | null;
    descriptive_name: string | null;
    is_discrete: boolean;
};

/**
 * A generic type for a scalar response from each of the members of the ensemble.
 */
export type EnsembleScalarResponse = {
    realizations: Array<number>;
    values: Array<number>;
    name: string | null;
    unit: string | null;
};

/**
 * Description/data for a single sensitivity in an ensemble
 */
export type EnsembleSensitivity = {
    name: string;
    type: SensitivityType;
    cases: Array<EnsembleSensitivityCase>;
};

/**
 * Description/data for a single sensitivity case in an ensemble
 */
export type EnsembleSensitivityCase = {
    name: string;
    realizations: Array<number>;
};

export type FenceMeshSection = {
    vertices_uz_b64arr: B64FloatArray;
    poly_indices_b64arr: B64UintArray;
    vertices_per_poly_b64arr: B64UintArray;
    poly_source_cell_indices_b64arr: B64UintArray;
    poly_props_b64arr: B64FloatArray;
    start_utm_x: number;
    start_utm_y: number;
    end_utm_x: number;
    end_utm_y: number;
};

export type FieldInfo = {
    field_identifier: string;
};

export type FlowNetworkData = {
    edgeMetadataList: Array<FlowNetworkMetadata>;
    nodeMetadataList: Array<FlowNetworkMetadata>;
    datedNetworks: Array<DatedFlowNetwork>;
};

export type FlowNetworkMetadata = {
    key: string;
    label: string;
    unit: string | null;
};

export enum FlowRateType {
    OIL = "OIL",
    LIQ = "LIQ",
    GAS = "GAS",
    WG = "WG",
    TM = "TM",
    WAT = "WAT",
}

export enum FluidZone {
    OIL = "Oil",
    GAS = "Gas",
    WATER = "Water",
}

export enum Frequency {
    DAILY = "DAILY",
    WEEKLY = "WEEKLY",
    MONTHLY = "MONTHLY",
    QUARTERLY = "QUARTERLY",
    YEARLY = "YEARLY",
}

export enum Gfr {
    GOR = "GOR",
    GLR = "GLR",
    OGR = "OGR",
    MMW = "MMW",
}

export type GraphUserPhoto = {
    avatar_b64str: string | null;
};

/**
 * Specification of a 3D grid dimensions
 */
export type Grid3dDimensions = {
    i_count: number;
    j_count: number;
    k_count: number;
    subgrids: Array<Grid3dZone>;
};

export type Grid3dGeometry = {
    polys_b64arr: B64UintArray;
    points_b64arr: B64FloatArray;
    poly_source_cell_indices_b64arr: B64UintArray;
    origin_utm_x: number;
    origin_utm_y: number;
    xmin: number;
    xmax: number;
    ymin: number;
    ymax: number;
    zmin: number;
    zmax: number;
};

/**
 * Metadata for a 3D grid model, including its properties and geometry
 */
export type Grid3dInfo = {
    grid_name: string;
    bbox: BoundingBox3D;
    dimensions: Grid3dDimensions;
    property_info_arr: Array<Grid3dPropertyInfo>;
};

export type Grid3dMappedProperty = {
    poly_props_b64arr: B64FloatArray;
    min_grid_prop_value: number;
    max_grid_prop_value: number;
};

/**
 * Metadata for a 3D grid property
 */
export type Grid3dPropertyInfo = {
    property_name: string;
    iso_date_or_interval: string | null;
};

/**
 * Named subset of 3D grid layers (Zone)
 */
export type Grid3dZone = {
    name: string;
    start_layer: number;
    end_layer: number;
};

export type GridDimensions = {
    i_count: number;
    j_count: number;
    k_count: number;
};

export type HttpValidationError = {
    detail?: Array<ValidationError>;
};

/**
 * Statistical volumetric data for single volume table
 *
 * Contains data for a single fluid zone, e.g. Oil, Gas, Water, or sum of fluid zones
 */
export type InplaceStatisticalVolumetricTableData = {
    fluidSelectionName: string;
    selectorColumns: Array<RepeatedTableColumnData>;
    resultColumnStatistics: Array<TableColumnStatisticalData>;
};

/**
 * Statistical volumetric data for a single table per fluid selection
 *
 * Fluid selection can be single fluid zones, e.g. Oil, Gas, Water, or sum of fluid zones - Oil + Gas + Water
 */
export type InplaceStatisticalVolumetricTableDataPerFluidSelection = {
    tableDataPerFluidSelection: Array<InplaceStatisticalVolumetricTableData>;
};

/**
 * Allowed volumetric response names
 */
export enum InplaceVolumetricResultName {
    BULK = "BULK",
    NET = "NET",
    PORO = "PORO",
    PORO_NET = "PORO_NET",
    PORV = "PORV",
    HCPV = "HCPV",
    STOIIP = "STOIIP",
    GIIP = "GIIP",
    NTG = "NTG",
    ASSOCIATEDGAS = "ASSOCIATEDGAS",
    ASSOCIATEDOIL = "ASSOCIATEDOIL",
    BO = "BO",
    BG = "BG",
    SW = "SW",
    STOIIP_TOTAL = "STOIIP_TOTAL",
    GIIP_TOTAL = "GIIP_TOTAL",
}

/**
 * Definition of possible statistics for a result column in an inplace volumetrics table
 */
export enum InplaceVolumetricStatistic {
    MEAN = "mean",
    STDDEV = "stddev",
    MAX = "max",
    MIN = "min",
    P10 = "p10",
    P90 = "p90",
}

/**
 * Volumetric data for a single table
 *
 * Contains data for a single fluid zone, e.g. Oil, Gas, Water, or sum of fluid zones
 */
export type InplaceVolumetricTableData = {
    fluidSelectionName: string;
    selectorColumns: Array<RepeatedTableColumnData>;
    resultColumns: Array<TableColumnData>;
};

/**
 * Volumetric data for a single table per fluid selection
 *
 * Fluid selection can be single fluid zones, e.g. Oil, Gas, Water, or sum of fluid zones - Oil + Gas + Water
 */
export type InplaceVolumetricTableDataPerFluidSelection = {
    tableDataPerFluidSelection: Array<InplaceVolumetricTableData>;
};

export enum InplaceVolumetricsIdentifier {
    ZONE = "ZONE",
    REGION = "REGION",
    FACIES = "FACIES",
    LICENSE = "LICENSE",
}

/**
 * Unique values for an index column in a volumetric table
 * All values should ideally be strings, but it is common to see integers, especially for REGION
 */
export type InplaceVolumetricsIdentifierWithValues = {
    identifier: InplaceVolumetricsIdentifier;
    values: Array<string | number>;
};

/**
 * Definition of a volumetric table
 */
export type InplaceVolumetricsTableDefinition = {
    tableName: string;
    fluidZones: Array<FluidZone>;
    resultNames: Array<InplaceVolumetricResultName>;
    identifiersWithValues: Array<InplaceVolumetricsIdentifierWithValues>;
};

export type NetworkNode = {
    node_type: "Group" | "Well";
    node_label: string;
    edge_label: string;
    node_data: {
        [key: string]: Array<number>;
    };
    edge_data: {
        [key: string]: Array<number>;
    };
    children: Array<NetworkNode>;
};

export enum NodeType {
    PROD = "prod",
    INJ = "inj",
    OTHER = "other",
}

/**
 * A collection of observations associated with a field/case/ensemble
 */
export type Observations = {
    summary: Array<SummaryVectorObservations>;
    rft: Array<RftObservations>;
};

export type PointSetXy = {
    x_points: Array<number>;
    y_points: Array<number>;
};

export type PolygonData = {
    x_arr: Array<number>;
    y_arr: Array<number>;
    z_arr: Array<number>;
    poly_id: number | string;
};

/**
 * To be revisited later when the metadata is more mature.
 */
export enum PolygonsAttributeType {
    DEPTH = "depth",
    TIME = "time",
    PROPERTY = "property",
    SEISMIC = "seismic",
    THICKNESS = "thickness",
    ISOCHORE = "isochore",
    FLUID_CONTACT = "fluid_contact",
    FIELD_OUTLINE = "field_outline",
    PINCHOUT = "pinchout",
    SUBCROP = "subcrop",
    FAULT_LINES = "fault_lines",
    NAMED_AREA = "named_area",
}

export type PolygonsMeta = {
    name: string;
    name_is_stratigraphic_offical: boolean;
    stratigraphic_identifier: string | null;
    relative_stratigraphic_level: number | null;
    parent_stratigraphic_identifier: string | null;
    attribute_name: string;
    attribute_type: PolygonsAttributeType;
};

export type PolylineIntersection = {
    fence_mesh_sections: Array<FenceMeshSection>;
    grid_dimensions: GridDimensions;
    min_grid_prop_value: number;
    max_grid_prop_value: number;
};

export type PvtData = {
    name: string;
    phase: string;
    pvtnum: number;
    ratio: Array<number>;
    pressure: Array<number>;
    volumefactor: Array<number>;
    viscosity: Array<number>;
    density: Array<number>;
    pressure_unit: string;
    volumefactor_unit: string;
    viscosity_unit: string;
    density_unit: string;
    ratio_unit: string;
};

/**
 * Data for a single column in a volumetric table
 *
 * Length of index list should be equal to the number of rows in the table
 *
 * - unique_values: List of unique values in the column
 * - indices: List of indices, in unique_values list, for each row in the table
 */
export type RepeatedTableColumnData = {
    columnName: string;
    uniqueValues: Array<string | number>;
    indices: Array<number>;
};

/**
 * A specific RFT (Repeat Formation Tester) observation.
 *
 * Attributes:
 * value (float): The measured value of the observation.
 * comment (Optional[str]): An optional comment associated with the observation.
 * error (float): The measurement error associated with the observation.
 * zone (str): The zone or region associated with the observation.
 * md_msl (float): Measured depth from mean sea level.
 * x (float): X utm coordinate of the observation.
 * y (float): Y utm coordinate of the observation.
 * z (float): Z utm coordinate of the observation.
 */
export type RftObservation = {
    value: number;
    comment: string | null;
    error: number;
    zone: string;
    md_msl: number;
    x: number;
    y: number;
    z: number;
};

/**
 * A collection of RFT (Repeat Formation Tester) observations for a specific well at a specific date.
 *
 * Attributes:
 * well (str): Unique well identifier
 * date (str): Observation date
 * comment (Optional[str]): An optional comment associated with the collection of observations.
 * observations (List[RftObservation]): A list of RFT observations associated with this collection.
 */
export type RftObservations = {
    well: string;
    date: string;
    comment: string | null;
    observations: Array<RftObservation>;
};

export type RftRealizationData = {
    well_name: string;
    realization: number;
    timestamp_utc_ms: number;
    depth_arr: Array<number>;
    value_arr: Array<number>;
};

export type RftTableDefinition = {
    response_names: Array<string>;
    well_infos: Array<RftWellInfo>;
};

export type RftWellInfo = {
    well_name: string;
    timestamps_utc_ms: Array<number>;
};

/**
 * Metadata for a seismic cube.
 */
export type SeismicCubeMeta = {
    seismicAttribute: string;
    unit: string;
    isoDateOrInterval: string;
    isObservation: boolean;
    isDepth: boolean;
    bbox: BoundingBox3D;
    spec: SeismicCubeSpec;
};

/**
 * Specification for a seismic cube.
 *
 * `Properties:`
 * - `numCols`: The number of columns in the seismic cube.
 * - `numRows`: The number of rows in the seismic cube.
 * - `numLayers`: The number of layers in the seismic cube.
 * - `xOrigin`: The x-coordinate of the origin of the cube [m].
 * - `yOrigin`: The y-coordinate of the origin of the cube [m].
 * - `zOrigin`: The z-coordinate of the origin of the cube [m].
 * - `xInc`: The increment in the x-direction [m].
 * - `yInc`: The increment in the y-direction [m].
 * - `zInc`: The increment in the z-direction [m].
 * - `yFlip`: {-1, 1} - The flip factor for the y-direction (1 if not flipped, -1 if flipped).
 * - `zFlip`: {-1, 1} - The flip factor for the z-direction (1 if not flipped, -1 if flipped).
 * - `rotationDeg`: The rotation angle of the cube [deg].
 */
export type SeismicCubeSpec = {
    numCols: number;
    numRows: number;
    numLayers: number;
    xOrigin: number;
    yOrigin: number;
    zOrigin: number;
    xInc: number;
    yInc: number;
    zInc: number;
    yFlip: number;
    zFlip: number;
    rotationDeg: number;
};

/**
 * Definition of a fence of seismic data from a set of (x, y) coordinates in domain coordinate system.
 * Each (x, y) point provides a trace perpendicular to the x-y plane, with number of samples equal to the depth of the seismic cube.
 *
 * Each trace is defined to be a set of depth value samples along the length direction of the fence.
 *
 * `Properties:`
 * - `fence_traces_b64arr`: The fence trace array is base64 encoded 1D float array - where data is stored trace by trace.
 * - `num_traces`: The number of traces in the fence trace array. Equals the number of (x, y) coordinates in requested polyline.
 * - `num_samples_per_trace`: The number of samples in each trace.
 * - `min_fence_depth`: The minimum depth value of the fence.
 * - `max_fence_depth`: The maximum depth value of the fence.
 *
 * `Description - fence_traces_b64arr:`
 *
 * The encoded fence trace array is a flattened array of traces, where data is stored trace by trace.
 * With `m = num_traces`, and `n = num_samples_per_trace`, the flattened array has length `mxn`.
 *
 * Fence traces 1D array: [trace_1_sample_1, trace_1_sample_2, ..., trace_1_sample_n, ..., trace_m_sample_1, trace_m_sample_2, ..., trace_m_sample_n]
 *
 *
 * See:
 * - VdsAxis: https://github.com/equinor/vds-slice/blob/ab6f39789bf3d3b59a8df14f1c4682d340dc0bf3/internal/core/core.go#L37-L55
 */
export type SeismicFenceData = {
    fence_traces_b64arr: B64FloatArray;
    num_traces: number;
    num_samples_per_trace: number;
    min_fence_depth: number;
    max_fence_depth: number;
};

/**
 * (x, y) points defining a polyline in domain coordinate system, to retrieve fence of seismic data.
 *
 * Expect equal number of x- and y-points.
 *
 * Note: Coordinates are in domain coordinate system (UTM).
 *
 * NOTE:
 * - Verify coordinates are in domain coordinate system (UTM)?
 * - Consider points_xy: List[float] - i.e. array with [x1, y1, x2, y2, ..., xn, yn] instead of x_points and y_points arrays?
 * - Ensure equal length of x_points and y_points arrays?
 */
export type SeismicFencePolyline = {
    x_points: Array<number>;
    y_points: Array<number>;
};

/**
 * Definition of a seismic slice from a seismic cube. This could be an inline, crossline, or depth slice.
 * u and v axes are the respective domain coordinate system axes, and the slice traces are the seismic data values.
 * The SeismicCubeMeta specification object (not part of this schema) provides a transformation matrix for converting
 * the slice data from its own coordinate system (u,v) to the global coordinate system.
 *
 * `Properties:`
 * - `slice_traces_b64arr`: The slice trace array is base64 encoded 1D float array - where data is stored trace by trace.
 * - `bbox_utm`: The bounding box of the slice in UTM coordinates.
 * - `u_min`: The minimum value of the u-axis.
 * - `u_max`: The maximum value of the u-axis.
 * - `u_num_samples`: The number of samples along the u-axis.
 * - `u_unit`: The unit of the u-axis.
 * - `v_min`: The minimum value of the v-axis.
 * - `v_max`: The maximum value of the v-axis.
 * - `v_num_samples`: The number of samples along the v-axis.
 * - `v_unit`: The unit of the v-axis.
 * - `value_min`: The minimum value of the seismic data values.
 * - `value_max`: The maximum value of the seismic data values.
 *
 * Fence traces 1D array: [trace_1_sample_1, trace_1_sample_2, ..., trace_1_sample_n, ..., trace_m_sample_1, trace_m_sample_2, ..., trace_m_sample_n]
 */
export type SeismicSliceData = {
    slice_traces_b64arr: B64FloatArray;
    bbox_utm: Array<Array<number>>;
    u_min: number;
    u_max: number;
    u_num_samples: number;
    u_unit: string;
    v_min: number;
    v_max: number;
    v_num_samples: number;
    v_unit: string;
    value_min: number;
    value_max: number;
};

export enum SensitivityType {
    MONTECARLO = "montecarlo",
    SCENARIO = "scenario",
}

export enum StatisticFunction {
    MEAN = "MEAN",
    MIN = "MIN",
    MAX = "MAX",
    P10 = "P10",
    P90 = "P90",
    P50 = "P50",
}

export type StatisticValueObject = {
    statisticFunction: StatisticFunction;
    values: Array<number>;
};

/**
 * Stratigraphic column from SMDA
 */
export type StratigraphicColumn = {
    identifier: string;
    areaType: string;
    status: string;
    type: string | null;
};

/**
 * Stratigraphic unit from SMDA
 *
 * Camel case attributes needed for esvIntersection component in front-end
 */
export type StratigraphicUnit = {
    identifier: string;
    top: string;
    base: string;
    stratUnitLevel: number;
    stratUnitType: string;
    topAge: number | number;
    baseAge: number | number;
    stratUnitParent: string | null;
    colorR: number;
    colorG: number;
    colorB: number;
    lithologyType: number | number | string;
};

/**
 * A single observation of a summary vector at a specific date.
 */
export type SummaryVectorDateObservation = {
    date: string;
    comment: string | null;
    value: number;
    error: number;
    label: string;
};

/**
 * A collection of observations of a summary vector.
 */
export type SummaryVectorObservations = {
    vector_name: string;
    comment: string | null;
    observations: Array<SummaryVectorDateObservation>;
};

/**
 * A surface has a single array with values, e.g. depth, time, property, seismic, thickness.
 * Only surfaces with depth and time have z-values that can be plotted in 3D.
 * The other attributes are scalar values that can be plotted in 2D or used as colormapping for 3D surfaces.
 *
 * Ideally if the attribute is a scalar, there should be corresponding z-values, but this information is not
 * available in the metadata.
 *
 * To be revisited later when the metadata is more mature.
 */
export enum SurfaceAttributeType {
    DEPTH = "depth",
    FACIES_THICKNESS = "facies_thickness",
    FLUID_CONTACT = "fluid_contact",
    PINCHOUT = "pinchout",
    PROPERTY = "property",
    SEISMIC = "seismic",
    SUBCROP = "subcrop",
    THICKNESS = "thickness",
    TIME = "time",
    VELOCITY = "velocity",
    VOLUMES = "volumes",
    UNKNOWN = "UNKNOWN",
}

export type SurfaceDataFloat = {
    format: "float";
    surface_def: SurfaceDef;
    transformed_bbox_utm: BoundingBox2D;
    value_min: number;
    value_max: number;
    values_b64arr: B64FloatArray;
};

export type SurfaceDataPng = {
    format: "png";
    surface_def: SurfaceDef;
    transformed_bbox_utm: BoundingBox2D;
    value_min: number;
    value_max: number;
    png_image_base64: string;
};

export type SurfaceDef = {
    npoints_x: number;
    npoints_y: number;
    inc_x: number;
    inc_y: number;
    origin_utm_x: number;
    origin_utm_y: number;
    rot_deg: number;
};

/**
 * (x, y) points defining a polyline in domain coordinate system, to retrieve intersection of a surface, with a cumulative length
 * between at each (x, y)-point coordinates in domain coordinate system.
 *
 * Expect equal number of x- and y-points.
 *
 * x_points: X-coordinates of polyline points.
 * y_points: Y-coordinates of polyline points.
 * cum_lengths: Cumulative lengths of the polyline segments, i.e. the length of the polyline up to each (x,y) point.
 *
 * The cumulative lengths can be e.g. measured depth along a well path.
 *
 * Note: Coordinates are in domain coordinate system (UTM)
 *
 * Note: Verify if cum_lengths is necessary with respect to xtgeo
 */
export type SurfaceIntersectionCumulativeLengthPolyline = {
    x_points: Array<number>;
    y_points: Array<number>;
    cum_lengths: Array<number>;
};

/**
 * Definition of a surface intersection made from a set of (x, y) coordinates.
 *
 * name: Name of the surface
 * z_points: Array of z-points (depth values) at the intersection points, i.e. depth value for each (x,y) point.
 * cum_lengths: Cumulative length values at the intersection points, i.e. accumulated length between each element in the z points.
 */
export type SurfaceIntersectionData = {
    name: string;
    z_points: Array<number>;
    cum_lengths: Array<number>;
};

export type SurfaceMeta = {
    name: string;
    name_is_stratigraphic_offical: boolean;
    attribute_name: string;
    attribute_type: SurfaceAttributeType;
    time_type: SurfaceTimeType;
    is_observation: boolean;
    value_min: number | null;
    value_max: number | null;
};

export type SurfaceMetaSet = {
    surfaces: Array<SurfaceMeta>;
    time_points_iso_str: Array<string>;
    time_intervals_iso_str: Array<string>;
    surface_names_in_strat_order: Array<string>;
};

export type SurfaceRealizationSampleValues = {
    realization: number;
    sampled_values: Array<number>;
};

export enum SurfaceStatisticFunction {
    MEAN = "MEAN",
    STD = "STD",
    MIN = "MIN",
    MAX = "MAX",
    P10 = "P10",
    P90 = "P90",
    P50 = "P50",
}

export enum SurfaceTimeType {
    NO_TIME = "NO_TIME",
    TIME_POINT = "TIME_POINT",
    INTERVAL = "INTERVAL",
}

export type Thp = "THP";

export enum TabType {
    BHP = "BHP",
    TEMP = "TEMP",
}

/**
 * Data for a single column in a volumetric table
 *
 * Length of column values should be equal to the number of rows in the table
 */
export type TableColumnData = {
    columnName: string;
    columnValues: Array<number>;
};

/**
 * Statistical data for a single result column in a volumetric table
 *
 * Length of column values should be equal to the number of rows in the table
 */
export type TableColumnStatisticalData = {
    columnName: string;
    statisticValues: {
        [key: string]: Array<number>;
    };
};

export enum UnitType {
    METRIC = "METRIC",
    FIELD = "FIELD",
    LAB = "LAB",
    PVT_M = "PVT-M",
    DEFAULT = "DEFAULT",
}

export type UserInfo = {
    username: string;
    display_name: string | null;
    avatar_b64str: string | null;
    has_sumo_access: boolean;
    has_smda_access: boolean;
};

export type ValidationError = {
    loc: Array<string | number>;
    msg: string;
    type: string;
};

export type VectorDescription = {
    name: string;
    descriptiveName: string;
    hasHistorical: boolean;
    derivedVectorInfo: DerivedVectorInfo | null;
};

export type VectorHistoricalData = {
    timestampsUtcMs: Array<number>;
    values: Array<number>;
    unit: string;
    isRate: boolean;
};

export type VectorRealizationData = {
    realization: number;
    timestampsUtcMs: Array<number>;
    values: Array<number>;
    unit: string;
    isRate: boolean;
    derivedVectorInfo: DerivedVectorInfo | null;
};

export type VectorStatisticData = {
    realizations: Array<number>;
    timestampsUtcMs: Array<number>;
    valueObjects: Array<StatisticValueObject>;
    unit: string;
    isRate: boolean;
    derivedVectorInfo: DerivedVectorInfo | null;
};

export type VectorStatisticSensitivityData = {
    realizations: Array<number>;
    timestampsUtcMs: Array<number>;
    valueObjects: Array<StatisticValueObject>;
    unit: string;
    isRate: boolean;
    sensitivityName: string;
    sensitivityCase: string;
};

export type VfpInjTable = {
    vfpType: "INJ";
    tableNumber: number;
    datum: number;
    flowRateType: FlowRateType;
    unitType: UnitType;
    tabType: TabType;
    thpValues: Array<number>;
    flowRateValues: Array<number>;
    bhpValues: Array<number>;
    flowRateUnit: string;
    thpUnit: string;
    bhpUnit: string;
};

export type VfpProdTable = {
    vfpType: "PROD";
    tableNumber: number;
    datum: number;
    flowRateType: FlowRateType;
    unitType: UnitType;
    tabType: TabType;
    thpValues: Array<number>;
    flowRateValues: Array<number>;
    bhpValues: Array<number>;
    flowRateUnit: string;
    thpUnit: string;
    bhpUnit: string;
    thpType: Thp;
    wfrType: Wfr;
    gfrType: Gfr;
    alqType: Alq;
    wfrValues: Array<number>;
    gfrValues: Array<number>;
    alqValues: Array<number>;
    wfrUnit: string;
    gfrUnit: string;
    alqUnit: string;
};

export enum Wfr {
    WOR = "WOR",
    WCT = "WCT",
    WGR = "WGR",
    WWR = "WWR",
    WTF = "WTF",
}

/**
 * Type definition for well completions data
 */
export type WellCompletionsData = {
    version: string;
    units: WellCompletionsUnits;
    zones: Array<WellCompletionsZone>;
    sortedCompletionDates: Array<string>;
    wells: Array<WellCompletionsWell>;
};

export type WellCompletionsUnitInfo = {
    unit: string;
    decimalPlaces: number;
};

export type WellCompletionsUnits = {
    kh: WellCompletionsUnitInfo;
};

export type WellCompletionsWell = {
    name: string;
    attributes: {
        [key: string]: string | number | boolean;
    };
    completions: {
        [key: string]: Completions;
    };
};

export type WellCompletionsZone = {
    name: string;
    subzones: Array<WellCompletionsZone> | null;
};

export enum WellLogCurveSourceEnum {
    SSDL_WELL_LOG = "ssdl.well_log",
    SMDA_GEOLOGY = "smda.geology",
    SMDA_STRATIGRAPHY = "smda.stratigraphy",
}

export enum WellLogCurveTypeEnum {
    CONTINUOUS = "continuous",
    DISCRETE = "discrete",
    FLAG = "flag",
}

export type WellboreCasing = {
    itemType: string;
    diameterNumeric: number;
    diameterInner: number;
    description: string | null;
    remark: string | null;
    depthTopMd: number;
    depthBottomMd: number;
    totalDepthMd: number;
    startDepth: number;
    endDepth: number;
};

export type WellboreCompletion = {
    mdTop: number;
    mdBottom: number;
    tvdTop: number | null;
    tvdBottom: number | null;
    description: string | null;
    symbolName: string | null;
    comment: string | null;
};

export type WellboreHeader = {
    wellboreUuid: string;
    uniqueWellboreIdentifier: string;
    wellUuid: string;
    uniqueWellIdentifier: string;
    wellEasting: number;
    wellNorthing: number;
    depthReferencePoint: string;
    depthReferenceElevation: number;
    wellborePurpose: string;
    wellboreStatus: string;
};

export type WellboreLogCurveData = {
    source: WellLogCurveSourceEnum;
    name: string;
    logName: string;
    indexMin: number;
    indexMax: number;
    minCurveValue: number | null;
    maxCurveValue: number | null;
    curveAlias: string | null;
    curveDescription: string | null;
    indexUnit: string;
    noDataValue: number | null;
    unit: string | null;
    curveUnitDesc: string | null;
    dataPoints: Array<[number, number | string | null]>;
    discreteValueMetadata: Array<DiscreteValueMetadata> | null;
};

export type WellboreLogCurveHeader = {
    source: WellLogCurveSourceEnum;
    curveType: WellLogCurveTypeEnum;
    logName: string;
    curveName: string;
    curveUnit: string | null;
};

export type WellborePerforation = {
    mdTop: number;
    mdBottom: number;
    tvdTop: number;
    tvdBottom: number;
    status: string;
    completionMode: string;
};

/**
 * Wellbore pick from SMDA
 *
 * Camel case attributes needed for esvIntersection component in front-end
 */
export type WellborePick = {
    northing: number;
    easting: number;
    tvd: number;
    tvdMsl: number;
    md: number;
    mdMsl: number;
    uniqueWellboreIdentifier: string;
    wellboreUuid: string;
    pickIdentifier: string;
    confidence: string | null;
    depthReferencePoint: string;
    mdUnit: string;
    interpreter: string | null;
};

export type WellboreTrajectory = {
    wellboreUuid: string;
    uniqueWellboreIdentifier: string;
    tvdMslArr: Array<number>;
    mdArr: Array<number>;
    eastingArr: Array<number>;
    northingArr: Array<number>;
};

export type GetFieldsData = {
    body?: never;
    path?: never;
    query?: never;
    url: "/fields";
};

export type GetFieldsResponses = {
    /**
     * Successful Response
     */
    200: Array<FieldInfo>;
};

export type GetFieldsResponse = GetFieldsResponses[keyof GetFieldsResponses];

export type GetCasesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Field identifier
         */
        field_identifier: string;
    };
    url: "/cases";
};

export type GetCasesErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetCasesError = GetCasesErrors[keyof GetCasesErrors];

export type GetCasesResponses = {
    /**
     * Successful Response
     */
    200: Array<CaseInfo>;
};

export type GetCasesResponse = GetCasesResponses[keyof GetCasesResponses];

export type GetEnsemblesData = {
    body?: never;
    path: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
    };
    query?: never;
    url: "/cases/{case_uuid}/ensembles";
};

export type GetEnsemblesErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetEnsemblesError = GetEnsemblesErrors[keyof GetEnsemblesErrors];

export type GetEnsemblesResponses = {
    /**
     * Successful Response
     */
    200: Array<EnsembleInfo>;
};

export type GetEnsemblesResponse = GetEnsemblesResponses[keyof GetEnsemblesResponses];

export type GetEnsembleDetailsData = {
    body?: never;
    path: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
    query?: never;
    url: "/cases/{case_uuid}/ensembles/{ensemble_name}";
};

export type GetEnsembleDetailsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetEnsembleDetailsError = GetEnsembleDetailsErrors[keyof GetEnsembleDetailsErrors];

export type GetEnsembleDetailsResponses = {
    /**
     * Successful Response
     */
    200: EnsembleDetails;
};

export type GetEnsembleDetailsResponse = GetEnsembleDetailsResponses[keyof GetEnsembleDetailsResponses];

export type GetVectorListData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Include derived vectors
         */
        include_derived_vectors?: boolean | null;
    };
    url: "/timeseries/vector_list/";
};

export type GetVectorListErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetVectorListError = GetVectorListErrors[keyof GetVectorListErrors];

export type GetVectorListResponses = {
    /**
     * Successful Response
     */
    200: Array<VectorDescription>;
};

export type GetVectorListResponse = GetVectorListResponses[keyof GetVectorListResponses];

export type GetDeltaEnsembleVectorListData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid for comparison ensemble
         */
        comparison_case_uuid: string;
        /**
         * Comparison ensemble name
         */
        comparison_ensemble_name: string;
        /**
         * Sumo case uuid for reference ensemble
         */
        reference_case_uuid: string;
        /**
         * Reference ensemble name
         */
        reference_ensemble_name: string;
        /**
         * Include derived vectors
         */
        include_derived_vectors?: boolean | null;
    };
    url: "/timeseries/delta_ensemble_vector_list/";
};

export type GetDeltaEnsembleVectorListErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetDeltaEnsembleVectorListError = GetDeltaEnsembleVectorListErrors[keyof GetDeltaEnsembleVectorListErrors];

export type GetDeltaEnsembleVectorListResponses = {
    /**
     * Successful Response
     */
    200: Array<VectorDescription>;
};

export type GetDeltaEnsembleVectorListResponse =
    GetDeltaEnsembleVectorListResponses[keyof GetDeltaEnsembleVectorListResponses];

export type GetRealizationsVectorDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Name of the vector
         */
        vector_name: string;
        /**
         * Resampling frequency. If not specified, raw data without resampling wil be returned.
         */
        resampling_frequency?: Frequency | null;
        /**
         * Optional list of realizations encoded as string to include. If not specified, all realizations will be included.
         */
        realizations_encoded_as_uint_list_str?: string | null;
    };
    url: "/timeseries/realizations_vector_data/";
};

export type GetRealizationsVectorDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetRealizationsVectorDataError = GetRealizationsVectorDataErrors[keyof GetRealizationsVectorDataErrors];

export type GetRealizationsVectorDataResponses = {
    /**
     * Successful Response
     */
    200: Array<VectorRealizationData>;
};

export type GetRealizationsVectorDataResponse =
    GetRealizationsVectorDataResponses[keyof GetRealizationsVectorDataResponses];

export type GetDeltaEnsembleRealizationsVectorDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid for comparison ensemble
         */
        comparison_case_uuid: string;
        /**
         * Comparison ensemble name
         */
        comparison_ensemble_name: string;
        /**
         * Sumo case uuid for reference ensemble
         */
        reference_case_uuid: string;
        /**
         * Reference ensemble name
         */
        reference_ensemble_name: string;
        /**
         * Name of the vector
         */
        vector_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency: Frequency;
        /**
         * Optional list of realizations encoded as string to include. If not specified, all realizations will be included.
         */
        realizations_encoded_as_uint_list_str?: string | null;
    };
    url: "/timeseries/delta_ensemble_realizations_vector_data/";
};

export type GetDeltaEnsembleRealizationsVectorDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetDeltaEnsembleRealizationsVectorDataError =
    GetDeltaEnsembleRealizationsVectorDataErrors[keyof GetDeltaEnsembleRealizationsVectorDataErrors];

export type GetDeltaEnsembleRealizationsVectorDataResponses = {
    /**
     * Successful Response
     */
    200: Array<VectorRealizationData>;
};

export type GetDeltaEnsembleRealizationsVectorDataResponse =
    GetDeltaEnsembleRealizationsVectorDataResponses[keyof GetDeltaEnsembleRealizationsVectorDataResponses];

export type GetTimestampsListData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency?: Frequency | null;
    };
    url: "/timeseries/timestamps_list/";
};

export type GetTimestampsListErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetTimestampsListError = GetTimestampsListErrors[keyof GetTimestampsListErrors];

export type GetTimestampsListResponses = {
    /**
     * Successful Response
     */
    200: Array<number>;
};

export type GetTimestampsListResponse = GetTimestampsListResponses[keyof GetTimestampsListResponses];

export type GetHistoricalVectorDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Name of the non-historical vector
         */
        non_historical_vector_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency?: Frequency | null;
    };
    url: "/timeseries/historical_vector_data/";
};

export type GetHistoricalVectorDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetHistoricalVectorDataError = GetHistoricalVectorDataErrors[keyof GetHistoricalVectorDataErrors];

export type GetHistoricalVectorDataResponses = {
    /**
     * Successful Response
     */
    200: VectorHistoricalData;
};

export type GetHistoricalVectorDataResponse = GetHistoricalVectorDataResponses[keyof GetHistoricalVectorDataResponses];

export type GetStatisticalVectorDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Name of the vector
         */
        vector_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency: Frequency;
        /**
         * Optional list of statistics to calculate. If not specified, all statistics will be calculated.
         */
        statistic_functions?: Array<StatisticFunction> | null;
        /**
         * Optional list of realizations encoded as string to include. If not specified, all realizations will be included.
         */
        realizations_encoded_as_uint_list_str?: string | null;
    };
    url: "/timeseries/statistical_vector_data/";
};

export type GetStatisticalVectorDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetStatisticalVectorDataError = GetStatisticalVectorDataErrors[keyof GetStatisticalVectorDataErrors];

export type GetStatisticalVectorDataResponses = {
    /**
     * Successful Response
     */
    200: VectorStatisticData;
};

export type GetStatisticalVectorDataResponse =
    GetStatisticalVectorDataResponses[keyof GetStatisticalVectorDataResponses];

export type GetDeltaEnsembleStatisticalVectorDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid for comparison ensemble
         */
        comparison_case_uuid: string;
        /**
         * Comparison ensemble name
         */
        comparison_ensemble_name: string;
        /**
         * Sumo case uuid for reference ensemble
         */
        reference_case_uuid: string;
        /**
         * Reference ensemble name
         */
        reference_ensemble_name: string;
        /**
         * Name of the vector
         */
        vector_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency: Frequency;
        /**
         * Optional list of statistics to calculate. If not specified, all statistics will be calculated.
         */
        statistic_functions?: Array<StatisticFunction> | null;
        /**
         * Optional list of realizations encoded as string to include. If not specified, all realizations will be included.
         */
        realizations_encoded_as_uint_list_str?: string | null;
    };
    url: "/timeseries/delta_ensemble_statistical_vector_data/";
};

export type GetDeltaEnsembleStatisticalVectorDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetDeltaEnsembleStatisticalVectorDataError =
    GetDeltaEnsembleStatisticalVectorDataErrors[keyof GetDeltaEnsembleStatisticalVectorDataErrors];

export type GetDeltaEnsembleStatisticalVectorDataResponses = {
    /**
     * Successful Response
     */
    200: VectorStatisticData;
};

export type GetDeltaEnsembleStatisticalVectorDataResponse =
    GetDeltaEnsembleStatisticalVectorDataResponses[keyof GetDeltaEnsembleStatisticalVectorDataResponses];

export type GetStatisticalVectorDataPerSensitivityData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Name of the vector
         */
        vector_name: string;
        /**
         * Resampling frequency
         */
        resampling_frequency: Frequency;
        /**
         * Optional list of statistics to calculate. If not specified, all statistics will be calculated.
         */
        statistic_functions?: Array<StatisticFunction> | null;
        /**
         * Optional list of realizations to include. If not specified, all realizations will be included.
         */
        realizations_encoded_as_uint_list_str?: string | null;
    };
    url: "/timeseries/statistical_vector_data_per_sensitivity/";
};

export type GetStatisticalVectorDataPerSensitivityErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetStatisticalVectorDataPerSensitivityError =
    GetStatisticalVectorDataPerSensitivityErrors[keyof GetStatisticalVectorDataPerSensitivityErrors];

export type GetStatisticalVectorDataPerSensitivityResponses = {
    /**
     * Successful Response
     */
    200: Array<VectorStatisticSensitivityData>;
};

export type GetStatisticalVectorDataPerSensitivityResponse =
    GetStatisticalVectorDataPerSensitivityResponses[keyof GetStatisticalVectorDataPerSensitivityResponses];

export type GetRealizationVectorAtTimestampData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Name of the vector
         */
        vector_name: string;
        /**
         * Timestamp in ms UTC to query vectors at
         */
        timestamp_utc_ms: number;
    };
    url: "/timeseries/realization_vector_at_timestamp/";
};

export type GetRealizationVectorAtTimestampErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetRealizationVectorAtTimestampError =
    GetRealizationVectorAtTimestampErrors[keyof GetRealizationVectorAtTimestampErrors];

export type GetRealizationVectorAtTimestampResponses = {
    /**
     * Successful Response
     */
    200: EnsembleScalarResponse;
};

export type GetRealizationVectorAtTimestampResponse =
    GetRealizationVectorAtTimestampResponses[keyof GetRealizationVectorAtTimestampResponses];

export type GetTableDefinitionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
    url: "/inplace_volumetrics/table_definitions/";
};

export type GetTableDefinitionsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetTableDefinitionsError = GetTableDefinitionsErrors[keyof GetTableDefinitionsErrors];

export type GetTableDefinitionsResponses = {
    /**
     * Successful Response
     */
    200: Array<InplaceVolumetricsTableDefinition>;
};

export type GetTableDefinitionsResponse = GetTableDefinitionsResponses[keyof GetTableDefinitionsResponses];

export type PostGetAggregatedPerRealizationTableDataData = {
    body: BodyPostGetAggregatedPerRealizationTableData;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Table name
         */
        table_name: string;
        /**
         * The name of the volumetric results
         */
        result_names: Array<string>;
        /**
         * The fluid zones to aggregate by
         */
        fluid_zones: Array<FluidZone>;
        /**
         * Whether to accumulate fluid zones
         */
        accumulate_fluid_zones: boolean;
        /**
         * The identifiers to group table data by
         */
        group_by_identifiers?: Array<InplaceVolumetricsIdentifier> | null;
        /**
         * Optional list of realizations encoded as string to include. If not specified, all realizations will be included.
         */
        realizations_encoded_as_uint_list_str?: string | null;
    };
    url: "/inplace_volumetrics/get_aggregated_per_realization_table_data/";
};

export type PostGetAggregatedPerRealizationTableDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type PostGetAggregatedPerRealizationTableDataError =
    PostGetAggregatedPerRealizationTableDataErrors[keyof PostGetAggregatedPerRealizationTableDataErrors];

export type PostGetAggregatedPerRealizationTableDataResponses = {
    /**
     * Successful Response
     */
    200: InplaceVolumetricTableDataPerFluidSelection;
};

export type PostGetAggregatedPerRealizationTableDataResponse =
    PostGetAggregatedPerRealizationTableDataResponses[keyof PostGetAggregatedPerRealizationTableDataResponses];

export type PostGetAggregatedStatisticalTableDataData = {
    body: BodyPostGetAggregatedStatisticalTableData;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Table name
         */
        table_name: string;
        /**
         * The name of the volumetric results
         */
        result_names: Array<string>;
        /**
         * The fluid zones to aggregate by
         */
        fluid_zones: Array<FluidZone>;
        /**
         * Whether to accumulate fluid zones
         */
        accumulate_fluid_zones: boolean;
        /**
         * The identifiers to group table data by
         */
        group_by_identifiers?: Array<InplaceVolumetricsIdentifier> | null;
        /**
         * Optional list of realizations encoded as string to include. If not specified, all realizations will be included.
         */
        realizations_encoded_as_uint_list_str?: string | null;
    };
    url: "/inplace_volumetrics/get_aggregated_statistical_table_data/";
};

export type PostGetAggregatedStatisticalTableDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type PostGetAggregatedStatisticalTableDataError =
    PostGetAggregatedStatisticalTableDataErrors[keyof PostGetAggregatedStatisticalTableDataErrors];

export type PostGetAggregatedStatisticalTableDataResponses = {
    /**
     * Successful Response
     */
    200: InplaceStatisticalVolumetricTableDataPerFluidSelection;
};

export type PostGetAggregatedStatisticalTableDataResponse =
    PostGetAggregatedStatisticalTableDataResponses[keyof PostGetAggregatedStatisticalTableDataResponses];

export type GetRealizationSurfacesMetadataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
    url: "/surface/realization_surfaces_metadata/";
};

export type GetRealizationSurfacesMetadataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetRealizationSurfacesMetadataError =
    GetRealizationSurfacesMetadataErrors[keyof GetRealizationSurfacesMetadataErrors];

export type GetRealizationSurfacesMetadataResponses = {
    /**
     * Successful Response
     */
    200: SurfaceMetaSet;
};

export type GetRealizationSurfacesMetadataResponse =
    GetRealizationSurfacesMetadataResponses[keyof GetRealizationSurfacesMetadataResponses];

export type GetObservedSurfacesMetadataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
    };
    url: "/surface/observed_surfaces_metadata/";
};

export type GetObservedSurfacesMetadataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetObservedSurfacesMetadataError =
    GetObservedSurfacesMetadataErrors[keyof GetObservedSurfacesMetadataErrors];

export type GetObservedSurfacesMetadataResponses = {
    /**
     * Successful Response
     */
    200: SurfaceMetaSet;
};

export type GetObservedSurfacesMetadataResponse =
    GetObservedSurfacesMetadataResponses[keyof GetObservedSurfacesMetadataResponses];

export type GetSurfaceDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Surface address string, supported address types are *REAL*, *OBS* and *STAT*
         */
        surf_addr_str: string;
        /**
         * Format of binary data in the response
         */
        data_format?: "float" | "png";
        /**
         * Definition of the surface onto which the data should be resampled. *SurfaceDef* object properties encoded as a `KeyValStr` string.
         */
        resample_to_def_str?: string | null;
    };
    url: "/surface/surface_data";
};

export type GetSurfaceDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetSurfaceDataError = GetSurfaceDataErrors[keyof GetSurfaceDataErrors];

export type GetSurfaceDataResponses = {
    /**
     * Successful Response
     */
    200: SurfaceDataFloat | SurfaceDataPng;
};

export type GetSurfaceDataResponse = GetSurfaceDataResponses[keyof GetSurfaceDataResponses];

export type PostGetSurfaceIntersectionData = {
    body: BodyPostGetSurfaceIntersection;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization number
         */
        realization_num: number;
        /**
         * Surface name
         */
        name: string;
        /**
         * Surface attribute
         */
        attribute: string;
        /**
         * Time point or time interval string
         */
        time_or_interval_str?: string | null;
    };
    url: "/surface/get_surface_intersection";
};

export type PostGetSurfaceIntersectionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type PostGetSurfaceIntersectionError = PostGetSurfaceIntersectionErrors[keyof PostGetSurfaceIntersectionErrors];

export type PostGetSurfaceIntersectionResponses = {
    /**
     * Successful Response
     */
    200: SurfaceIntersectionData;
};

export type PostGetSurfaceIntersectionResponse =
    PostGetSurfaceIntersectionResponses[keyof PostGetSurfaceIntersectionResponses];

export type PostGetSampleSurfaceInPointsData = {
    body: BodyPostGetSampleSurfaceInPoints;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Surface name
         */
        surface_name: string;
        /**
         * Surface attribute
         */
        surface_attribute: string;
        /**
         * Realization numbers
         */
        realization_nums: Array<number>;
    };
    url: "/surface/get_sample_surface_in_points";
};

export type PostGetSampleSurfaceInPointsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type PostGetSampleSurfaceInPointsError =
    PostGetSampleSurfaceInPointsErrors[keyof PostGetSampleSurfaceInPointsErrors];

export type PostGetSampleSurfaceInPointsResponses = {
    /**
     * Successful Response
     */
    200: Array<SurfaceRealizationSampleValues>;
};

export type PostGetSampleSurfaceInPointsResponse =
    PostGetSampleSurfaceInPointsResponses[keyof PostGetSampleSurfaceInPointsResponses];

export type GetDeltaSurfaceDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Address string of surface A, supported types: *REAL*, *OBS* and *STAT*
         */
        surf_a_addr_str: string;
        /**
         * Address string of surface B, supported types: *REAL*, *OBS* and *STAT*
         */
        surf_b_addr_str: string;
        /**
         * Format of binary data in the response
         */
        data_format?: "float" | "png";
        /**
         * Definition of the surface onto which the data should be resampled. *SurfaceDef* object properties encoded as a `KeyValStr` string.
         */
        resample_to_def_str?: string | null;
    };
    url: "/surface/delta_surface_data";
};

export type GetDeltaSurfaceDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetDeltaSurfaceDataError = GetDeltaSurfaceDataErrors[keyof GetDeltaSurfaceDataErrors];

export type GetDeltaSurfaceDataResponses = {
    /**
     * Successful Response
     */
    200: Array<SurfaceDataFloat>;
};

export type GetDeltaSurfaceDataResponse = GetDeltaSurfaceDataResponses[keyof GetDeltaSurfaceDataResponses];

export type GetMisfitSurfaceDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Address of observed surface, only supported address type is *OBS*
         */
        obs_surf_addr_str: string;
        /**
         * Address of simulated surface, supported type is *PARTIAL*
         */
        sim_surf_addr_str: string;
        /**
         * Statistics to calculate
         */
        statistic_functions: Array<SurfaceStatisticFunction>;
        /**
         * Optional list of realizations encoded as string to include. If not specified, all realizations will be included.
         */
        realizations_encoded_as_uint_list_str?: string | null;
        /**
         * Format of binary data in the response
         */
        data_format?: "float" | "png";
        /**
         * Definition of the surface onto which the data should be resampled. *SurfaceDef* object properties encoded as a `KeyValStr` string.
         */
        resample_to_def_str?: string | null;
    };
    url: "/surface/misfit_surface_data";
};

export type GetMisfitSurfaceDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetMisfitSurfaceDataError = GetMisfitSurfaceDataErrors[keyof GetMisfitSurfaceDataErrors];

export type GetMisfitSurfaceDataResponses = {
    /**
     * Successful Response
     */
    200: Array<SurfaceDataFloat>;
};

export type GetMisfitSurfaceDataResponse = GetMisfitSurfaceDataResponses[keyof GetMisfitSurfaceDataResponses];

export type GetWellboreStratigraphicColumnsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
    url: "/surface/wellbore_stratigraphic_columns/";
};

export type GetWellboreStratigraphicColumnsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellboreStratigraphicColumnsError =
    GetWellboreStratigraphicColumnsErrors[keyof GetWellboreStratigraphicColumnsErrors];

export type GetWellboreStratigraphicColumnsResponses = {
    /**
     * Successful Response
     */
    200: Array<StratigraphicColumn>;
};

export type GetWellboreStratigraphicColumnsResponse =
    GetWellboreStratigraphicColumnsResponses[keyof GetWellboreStratigraphicColumnsResponses];

export type GetStratigraphicUnitsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
    };
    url: "/surface/stratigraphic_units";
};

export type GetStratigraphicUnitsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetStratigraphicUnitsError = GetStratigraphicUnitsErrors[keyof GetStratigraphicUnitsErrors];

export type GetStratigraphicUnitsResponses = {
    /**
     * Successful Response
     */
    200: Array<StratigraphicUnit>;
};

export type GetStratigraphicUnitsResponse = GetStratigraphicUnitsResponses[keyof GetStratigraphicUnitsResponses];

export type GetParameterNamesAndDescriptionData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Exclude all parameters where all values are the same value
         */
        exclude_all_values_constant?: boolean;
        /**
         * Sort order
         */
        sort_order?: "alphabetically" | "standard_deviation";
    };
    url: "/parameters/parameter_names_and_description/";
};

export type GetParameterNamesAndDescriptionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetParameterNamesAndDescriptionError =
    GetParameterNamesAndDescriptionErrors[keyof GetParameterNamesAndDescriptionErrors];

export type GetParameterNamesAndDescriptionResponses = {
    /**
     * Successful Response
     */
    200: Array<EnsembleParameterDescription>;
};

export type GetParameterNamesAndDescriptionResponse =
    GetParameterNamesAndDescriptionResponses[keyof GetParameterNamesAndDescriptionResponses];

export type GetParameterData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Parameter name
         */
        parameter_name: string;
    };
    url: "/parameters/parameter/";
};

export type GetParameterErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetParameterError = GetParameterErrors[keyof GetParameterErrors];

export type GetParameterResponses = {
    /**
     * Successful Response
     */
    200: EnsembleParameter | null;
};

export type GetParameterResponse = GetParameterResponses[keyof GetParameterResponses];

export type GetParametersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
    url: "/parameters/parameters/";
};

export type GetParametersErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetParametersError = GetParametersErrors[keyof GetParametersErrors];

export type GetParametersResponses = {
    /**
     * Successful Response
     */
    200: Array<EnsembleParameter>;
};

export type GetParametersResponse = GetParametersResponses[keyof GetParametersResponses];

export type GetIsSensitivityRunData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
    url: "/parameters/is_sensitivity_run/";
};

export type GetIsSensitivityRunErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetIsSensitivityRunError = GetIsSensitivityRunErrors[keyof GetIsSensitivityRunErrors];

export type GetIsSensitivityRunResponses = {
    /**
     * Successful Response
     */
    200: boolean;
};

export type GetIsSensitivityRunResponse = GetIsSensitivityRunResponses[keyof GetIsSensitivityRunResponses];

export type GetSensitivitiesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
    url: "/parameters/sensitivities/";
};

export type GetSensitivitiesErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetSensitivitiesError = GetSensitivitiesErrors[keyof GetSensitivitiesErrors];

export type GetSensitivitiesResponses = {
    /**
     * Successful Response
     */
    200: Array<EnsembleSensitivity>;
};

export type GetSensitivitiesResponse = GetSensitivitiesResponses[keyof GetSensitivitiesResponses];

export type GetGridModelsInfoData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization
         */
        realization_num: number;
    };
    url: "/grid3d/grid_models_info/";
};

export type GetGridModelsInfoErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetGridModelsInfoError = GetGridModelsInfoErrors[keyof GetGridModelsInfoErrors];

export type GetGridModelsInfoResponses = {
    /**
     * Successful Response
     */
    200: Array<Grid3dInfo>;
};

export type GetGridModelsInfoResponse = GetGridModelsInfoResponses[keyof GetGridModelsInfoResponses];

export type GetGridSurfaceData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
        /**
         * Realization
         */
        realization_num: number;
        /**
         * Min i index
         */
        i_min?: number;
        /**
         * Max i index
         */
        i_max?: number;
        /**
         * Min j index
         */
        j_min?: number;
        /**
         * Max j index
         */
        j_max?: number;
        /**
         * Min k index
         */
        k_min?: number;
        /**
         * Max k index
         */
        k_max?: number;
    };
    url: "/grid3d/grid_surface";
};

export type GetGridSurfaceErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetGridSurfaceError = GetGridSurfaceErrors[keyof GetGridSurfaceErrors];

export type GetGridSurfaceResponses = {
    /**
     * Successful Response
     */
    200: Grid3dGeometry;
};

export type GetGridSurfaceResponse = GetGridSurfaceResponses[keyof GetGridSurfaceResponses];

export type GetGridParameterData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
        /**
         * Grid parameter
         */
        parameter_name: string;
        /**
         * Realization
         */
        realization_num: number;
        /**
         * Time point or time interval string
         */
        parameter_time_or_interval_str?: string | null;
        /**
         * Min i index
         */
        i_min?: number;
        /**
         * Max i index
         */
        i_max?: number;
        /**
         * Min j index
         */
        j_min?: number;
        /**
         * Max j index
         */
        j_max?: number;
        /**
         * Min k index
         */
        k_min?: number;
        /**
         * Max k index
         */
        k_max?: number;
    };
    url: "/grid3d/grid_parameter";
};

export type GetGridParameterErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetGridParameterError = GetGridParameterErrors[keyof GetGridParameterErrors];

export type GetGridParameterResponses = {
    /**
     * Successful Response
     */
    200: Grid3dMappedProperty;
};

export type GetGridParameterResponse = GetGridParameterResponses[keyof GetGridParameterResponses];

export type PostGetPolylineIntersectionData = {
    body: BodyPostGetPolylineIntersection;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Grid name
         */
        grid_name: string;
        /**
         * Grid parameter
         */
        parameter_name: string;
        /**
         * Realization
         */
        realization_num: number;
        /**
         * Time point or time interval string
         */
        parameter_time_or_interval_str?: string | null;
    };
    url: "/grid3d/get_polyline_intersection";
};

export type PostGetPolylineIntersectionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type PostGetPolylineIntersectionError =
    PostGetPolylineIntersectionErrors[keyof PostGetPolylineIntersectionErrors];

export type PostGetPolylineIntersectionResponses = {
    /**
     * Successful Response
     */
    200: PolylineIntersection;
};

export type PostGetPolylineIntersectionResponse =
    PostGetPolylineIntersectionResponses[keyof PostGetPolylineIntersectionResponses];

export type GetRealizationFlowNetworkData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization
         */
        realization: number;
        /**
         * Resampling frequency
         */
        resampling_frequency: Frequency;
        /**
         * Node types
         */
        node_type_set: Array<NodeType>;
    };
    url: "/flow_network/realization_flow_network/";
};

export type GetRealizationFlowNetworkErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetRealizationFlowNetworkError = GetRealizationFlowNetworkErrors[keyof GetRealizationFlowNetworkErrors];

export type GetRealizationFlowNetworkResponses = {
    /**
     * Successful Response
     */
    200: FlowNetworkData;
};

export type GetRealizationFlowNetworkResponse =
    GetRealizationFlowNetworkResponses[keyof GetRealizationFlowNetworkResponses];

export type GetTableDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization number
         */
        realization: number;
    };
    url: "/pvt/table_data/";
};

export type GetTableDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetTableDataError = GetTableDataErrors[keyof GetTableDataErrors];

export type GetTableDataResponses = {
    /**
     * Successful Response
     */
    200: Array<PvtData>;
};

export type GetTableDataResponse = GetTableDataResponses[keyof GetTableDataResponses];

export type GetWellCompletionsDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Optional realizations to include. Provide single realization or list of realizations. If not specified, all realizations will be returned.
         */
        realization?: number | Array<number> | null;
    };
    url: "/well_completions/well_completions_data/";
};

export type GetWellCompletionsDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellCompletionsDataError = GetWellCompletionsDataErrors[keyof GetWellCompletionsDataErrors];

export type GetWellCompletionsDataResponses = {
    /**
     * Successful Response
     */
    200: WellCompletionsData;
};

export type GetWellCompletionsDataResponse = GetWellCompletionsDataResponses[keyof GetWellCompletionsDataResponses];

export type GetDrilledWellboreHeadersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Official field identifier
         */
        field_identifier: string;
    };
    url: "/well/drilled_wellbore_headers/";
};

export type GetDrilledWellboreHeadersErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetDrilledWellboreHeadersError = GetDrilledWellboreHeadersErrors[keyof GetDrilledWellboreHeadersErrors];

export type GetDrilledWellboreHeadersResponses = {
    /**
     * Successful Response
     */
    200: Array<WellboreHeader>;
};

export type GetDrilledWellboreHeadersResponse =
    GetDrilledWellboreHeadersResponses[keyof GetDrilledWellboreHeadersResponses];

export type GetWellTrajectoriesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Official field identifier
         */
        field_identifier: string;
        /**
         * Optional subset of wellbore uuids
         */
        wellbore_uuids?: Array<string> | null;
    };
    url: "/well/well_trajectories/";
};

export type GetWellTrajectoriesErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellTrajectoriesError = GetWellTrajectoriesErrors[keyof GetWellTrajectoriesErrors];

export type GetWellTrajectoriesResponses = {
    /**
     * Successful Response
     */
    200: Array<WellboreTrajectory>;
};

export type GetWellTrajectoriesResponse = GetWellTrajectoriesResponses[keyof GetWellTrajectoriesResponses];

export type GetWellborePickIdentifiersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Stratigraphic column identifier
         */
        strat_column_identifier: string;
    };
    url: "/well/wellbore_pick_identifiers/";
};

export type GetWellborePickIdentifiersErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellborePickIdentifiersError = GetWellborePickIdentifiersErrors[keyof GetWellborePickIdentifiersErrors];

export type GetWellborePickIdentifiersResponses = {
    /**
     * Successful Response
     */
    200: Array<string>;
};

export type GetWellborePickIdentifiersResponse =
    GetWellborePickIdentifiersResponses[keyof GetWellborePickIdentifiersResponses];

export type GetWellborePicksForPickIdentifierData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Official field identifier
         */
        field_identifier: string;
        /**
         * Pick identifier
         */
        pick_identifier: string;
    };
    url: "/well/wellbore_picks_for_pick_identifier/";
};

export type GetWellborePicksForPickIdentifierErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellborePicksForPickIdentifierError =
    GetWellborePicksForPickIdentifierErrors[keyof GetWellborePicksForPickIdentifierErrors];

export type GetWellborePicksForPickIdentifierResponses = {
    /**
     * Successful Response
     */
    200: Array<WellborePick>;
};

export type GetWellborePicksForPickIdentifierResponse =
    GetWellborePicksForPickIdentifierResponses[keyof GetWellborePicksForPickIdentifierResponses];

export type GetWellborePicksForWellboreData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
    url: "/well/wellbore_picks_for_wellbore/";
};

export type GetWellborePicksForWellboreErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellborePicksForWellboreError =
    GetWellborePicksForWellboreErrors[keyof GetWellborePicksForWellboreErrors];

export type GetWellborePicksForWellboreResponses = {
    /**
     * Successful Response
     */
    200: Array<WellborePick>;
};

export type GetWellborePicksForWellboreResponse =
    GetWellborePicksForWellboreResponses[keyof GetWellborePicksForWellboreResponses];

export type GetWellborePicksInStratColumnData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
        /**
         * Optional - Filter by stratigraphic column
         */
        strat_column: string;
    };
    url: "/well/wellbore_picks_in_strat_column";
};

export type GetWellborePicksInStratColumnErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellborePicksInStratColumnError =
    GetWellborePicksInStratColumnErrors[keyof GetWellborePicksInStratColumnErrors];

export type GetWellborePicksInStratColumnResponses = {
    /**
     * Successful Response
     */
    200: Array<WellborePick>;
};

export type GetWellborePicksInStratColumnResponse =
    GetWellborePicksInStratColumnResponses[keyof GetWellborePicksInStratColumnResponses];

export type GetWellboreCompletionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
    url: "/well/wellbore_completions/";
};

export type GetWellboreCompletionsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellboreCompletionsError = GetWellboreCompletionsErrors[keyof GetWellboreCompletionsErrors];

export type GetWellboreCompletionsResponses = {
    /**
     * Successful Response
     */
    200: Array<WellboreCompletion>;
};

export type GetWellboreCompletionsResponse = GetWellboreCompletionsResponses[keyof GetWellboreCompletionsResponses];

export type GetWellboreCasingsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
    url: "/well/wellbore_casings/";
};

export type GetWellboreCasingsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellboreCasingsError = GetWellboreCasingsErrors[keyof GetWellboreCasingsErrors];

export type GetWellboreCasingsResponses = {
    /**
     * Successful Response
     */
    200: Array<WellboreCasing>;
};

export type GetWellboreCasingsResponse = GetWellboreCasingsResponses[keyof GetWellboreCasingsResponses];

export type GetWellborePerforationsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
    };
    url: "/well/wellbore_perforations/";
};

export type GetWellborePerforationsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellborePerforationsError = GetWellborePerforationsErrors[keyof GetWellborePerforationsErrors];

export type GetWellborePerforationsResponses = {
    /**
     * Successful Response
     */
    200: Array<WellborePerforation>;
};

export type GetWellborePerforationsResponse = GetWellborePerforationsResponses[keyof GetWellborePerforationsResponses];

export type GetWellboreLogCurveHeadersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
        /**
         * Sources to fetch well-logs from.
         */
        sources?: Array<WellLogCurveSourceEnum>;
    };
    url: "/well/wellbore_log_curve_headers/";
};

export type GetWellboreLogCurveHeadersErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetWellboreLogCurveHeadersError = GetWellboreLogCurveHeadersErrors[keyof GetWellboreLogCurveHeadersErrors];

export type GetWellboreLogCurveHeadersResponses = {
    /**
     * Successful Response
     */
    200: Array<WellboreLogCurveHeader>;
};

export type GetWellboreLogCurveHeadersResponse =
    GetWellboreLogCurveHeadersResponses[keyof GetWellboreLogCurveHeadersResponses];

export type GetLogCurveDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Wellbore uuid
         */
        wellbore_uuid: string;
        /**
         * Log identifier
         */
        log_name: string;
        /**
         * Curve identifier
         */
        curve_name: string;
        /**
         * Source to fetch well-logs from.
         */
        source?: WellLogCurveSourceEnum;
    };
    url: "/well/log_curve_data/";
};

export type GetLogCurveDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetLogCurveDataError = GetLogCurveDataErrors[keyof GetLogCurveDataErrors];

export type GetLogCurveDataResponses = {
    /**
     * Successful Response
     */
    200: WellboreLogCurveData;
};

export type GetLogCurveDataResponse = GetLogCurveDataResponses[keyof GetLogCurveDataResponses];

export type GetSeismicCubeMetaListData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
    url: "/seismic/seismic_cube_meta_list/";
};

export type GetSeismicCubeMetaListErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetSeismicCubeMetaListError = GetSeismicCubeMetaListErrors[keyof GetSeismicCubeMetaListErrors];

export type GetSeismicCubeMetaListResponses = {
    /**
     * Successful Response
     */
    200: Array<SeismicCubeMeta>;
};

export type GetSeismicCubeMetaListResponse = GetSeismicCubeMetaListResponses[keyof GetSeismicCubeMetaListResponses];

export type GetInlineSliceData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization number
         */
        realization_num: number;
        /**
         * Seismic cube attribute
         */
        seismic_attribute: string;
        /**
         * Timestamp or timestep
         */
        time_or_interval_str: string;
        /**
         * Observed or simulated
         */
        observed: boolean;
        /**
         * Inline number
         */
        inline_no: number;
    };
    url: "/seismic/get_inline_slice/";
};

export type GetInlineSliceErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetInlineSliceError = GetInlineSliceErrors[keyof GetInlineSliceErrors];

export type GetInlineSliceResponses = {
    /**
     * Successful Response
     */
    200: SeismicSliceData;
};

export type GetInlineSliceResponse = GetInlineSliceResponses[keyof GetInlineSliceResponses];

export type GetCrosslineSliceData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization number
         */
        realization_num: number;
        /**
         * Seismic cube attribute
         */
        seismic_attribute: string;
        /**
         * Timestamp or timestep
         */
        time_or_interval_str: string;
        /**
         * Observed or simulated
         */
        observed: boolean;
        /**
         * Crossline number
         */
        crossline_no: number;
    };
    url: "/seismic/get_crossline_slice/";
};

export type GetCrosslineSliceErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetCrosslineSliceError = GetCrosslineSliceErrors[keyof GetCrosslineSliceErrors];

export type GetCrosslineSliceResponses = {
    /**
     * Successful Response
     */
    200: SeismicSliceData;
};

export type GetCrosslineSliceResponse = GetCrosslineSliceResponses[keyof GetCrosslineSliceResponses];

export type GetDepthSliceData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization number
         */
        realization_num: number;
        /**
         * Seismic cube attribute
         */
        seismic_attribute: string;
        /**
         * Timestamp or timestep
         */
        time_or_interval_str: string;
        /**
         * Observed or simulated
         */
        observed: boolean;
        /**
         * Depth slice no
         */
        depth_slice_no: number;
    };
    url: "/seismic/get_depth_slice/";
};

export type GetDepthSliceErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetDepthSliceError = GetDepthSliceErrors[keyof GetDepthSliceErrors];

export type GetDepthSliceResponses = {
    /**
     * Successful Response
     */
    200: SeismicSliceData;
};

export type GetDepthSliceResponse = GetDepthSliceResponses[keyof GetDepthSliceResponses];

export type PostGetSeismicFenceData = {
    body: BodyPostGetSeismicFence;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization number
         */
        realization_num: number;
        /**
         * Seismic cube attribute
         */
        seismic_attribute: string;
        /**
         * Timestamp or timestep
         */
        time_or_interval_str: string;
        /**
         * Observed or simulated
         */
        observed: boolean;
    };
    url: "/seismic/get_seismic_fence/";
};

export type PostGetSeismicFenceErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type PostGetSeismicFenceError = PostGetSeismicFenceErrors[keyof PostGetSeismicFenceErrors];

export type PostGetSeismicFenceResponses = {
    /**
     * Successful Response
     */
    200: SeismicFenceData;
};

export type PostGetSeismicFenceResponse = PostGetSeismicFenceResponses[keyof PostGetSeismicFenceResponses];

export type GetPolygonsDirectoryData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
    url: "/polygons/polygons_directory/";
};

export type GetPolygonsDirectoryErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetPolygonsDirectoryError = GetPolygonsDirectoryErrors[keyof GetPolygonsDirectoryErrors];

export type GetPolygonsDirectoryResponses = {
    /**
     * Successful Response
     */
    200: Array<PolygonsMeta>;
};

export type GetPolygonsDirectoryResponse = GetPolygonsDirectoryResponses[keyof GetPolygonsDirectoryResponses];

export type GetPolygonsDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization number
         */
        realization_num: number;
        /**
         * Surface name
         */
        name: string;
        /**
         * Surface attribute
         */
        attribute: string;
    };
    url: "/polygons/polygons_data/";
};

export type GetPolygonsDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetPolygonsDataError = GetPolygonsDataErrors[keyof GetPolygonsDataErrors];

export type GetPolygonsDataResponses = {
    /**
     * Successful Response
     */
    200: Array<PolygonData>;
};

export type GetPolygonsDataResponse = GetPolygonsDataResponses[keyof GetPolygonsDataResponses];

export type GetUserPhotoData = {
    body?: never;
    path?: never;
    query: {
        /**
         * User id
         */
        user_id: string;
    };
    url: "/graph/user_photo/";
};

export type GetUserPhotoErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetUserPhotoError = GetUserPhotoErrors[keyof GetUserPhotoErrors];

export type GetUserPhotoResponses = {
    /**
     * Successful Response
     */
    200: GraphUserPhoto;
};

export type GetUserPhotoResponse = GetUserPhotoResponses[keyof GetUserPhotoResponses];

export type GetObservationsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
    };
    url: "/observations/observations/";
};

export type GetObservationsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetObservationsError = GetObservationsErrors[keyof GetObservationsErrors];

export type GetObservationsResponses = {
    /**
     * Successful Response
     */
    200: Observations;
};

export type GetObservationsResponse = GetObservationsResponses[keyof GetObservationsResponses];

export type GetTableDefinitionData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
    };
    url: "/rft/table_definition";
};

export type GetTableDefinitionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetTableDefinitionError = GetTableDefinitionErrors[keyof GetTableDefinitionErrors];

export type GetTableDefinitionResponses = {
    /**
     * Successful Response
     */
    200: RftTableDefinition;
};

export type GetTableDefinitionResponse = GetTableDefinitionResponses[keyof GetTableDefinitionResponses];

export type GetRealizationDataData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Well name
         */
        well_name: string;
        /**
         * Response name
         */
        response_name: string;
        /**
         * Timestamps utc ms
         */
        timestamps_utc_ms?: Array<number> | null;
        /**
         * Optional list of realizations encoded as string to include. If not specified, all realizations will be included.
         */
        realizations_encoded_as_uint_list_str?: string | null;
    };
    url: "/rft/realization_data";
};

export type GetRealizationDataErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetRealizationDataError = GetRealizationDataErrors[keyof GetRealizationDataErrors];

export type GetRealizationDataResponses = {
    /**
     * Successful Response
     */
    200: Array<RftRealizationData>;
};

export type GetRealizationDataResponse = GetRealizationDataResponses[keyof GetRealizationDataResponses];

export type GetVfpTableNamesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization
         */
        realization: number;
    };
    url: "/vfp/vfp_table_names/";
};

export type GetVfpTableNamesErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetVfpTableNamesError = GetVfpTableNamesErrors[keyof GetVfpTableNamesErrors];

export type GetVfpTableNamesResponses = {
    /**
     * Successful Response
     */
    200: Array<string>;
};

export type GetVfpTableNamesResponse = GetVfpTableNamesResponses[keyof GetVfpTableNamesResponses];

export type GetVfpTableData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Sumo case uuid
         */
        case_uuid: string;
        /**
         * Ensemble name
         */
        ensemble_name: string;
        /**
         * Realization
         */
        realization: number;
        /**
         * VFP table name
         */
        vfp_table_name: string;
    };
    url: "/vfp/vfp_table/";
};

export type GetVfpTableErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetVfpTableError = GetVfpTableErrors[keyof GetVfpTableErrors];

export type GetVfpTableResponses = {
    /**
     * Successful Response
     */
    200: VfpProdTable | VfpInjTable;
};

export type GetVfpTableResponse = GetVfpTableResponses[keyof GetVfpTableResponses];

export type LoginRouteData = {
    body?: never;
    path?: never;
    query?: {
        redirect_url_after_login?: string | null;
    };
    url: "/login";
};

export type LoginRouteErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type LoginRouteError = LoginRouteErrors[keyof LoginRouteErrors];

export type LoginRouteResponses = {
    /**
     * Successful Response
     */
    200: unknown;
};

export type AuthorizedCallbackRouteData = {
    body?: never;
    path?: never;
    query?: never;
    url: "/auth-callback";
};

export type AuthorizedCallbackRouteResponses = {
    /**
     * Successful Response
     */
    200: unknown;
};

export type GetAliveData = {
    body?: never;
    path?: never;
    query?: never;
    url: "/alive";
};

export type GetAliveResponses = {
    /**
     * Successful Response
     */
    200: string;
};

export type GetAliveResponse = GetAliveResponses[keyof GetAliveResponses];

export type GetAliveProtectedData = {
    body?: never;
    path?: never;
    query?: never;
    url: "/alive_protected";
};

export type GetAliveProtectedResponses = {
    /**
     * Successful Response
     */
    200: string;
};

export type GetAliveProtectedResponse = GetAliveProtectedResponses[keyof GetAliveProtectedResponses];

export type PostLogoutData = {
    body?: never;
    path?: never;
    query?: never;
    url: "/logout";
};

export type PostLogoutResponses = {
    /**
     * Successful Response
     */
    200: string;
};

export type PostLogoutResponse = PostLogoutResponses[keyof PostLogoutResponses];

export type GetLoggedInUserData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Set to true to include user avatar and display name from Microsoft Graph API
         */
        includeGraphApiInfo?: boolean;
    };
    url: "/logged_in_user";
};

export type GetLoggedInUserErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetLoggedInUserError = GetLoggedInUserErrors[keyof GetLoggedInUserErrors];

export type GetLoggedInUserResponses = {
    /**
     * Successful Response
     */
    200: UserInfo;
};

export type GetLoggedInUserResponse = GetLoggedInUserResponses[keyof GetLoggedInUserResponses];

export type RootData = {
    body?: never;
    path?: never;
    query?: never;
    url: "/";
};

export type RootResponses = {
    /**
     * Successful Response
     */
    200: string;
};

export type RootResponse = RootResponses[keyof RootResponses];
